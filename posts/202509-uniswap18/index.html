<!DOCTYPE html>
<html itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <head>
    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
    <meta name="robots" content="noodp" />
    <title>18.Uniswap V3 手续费计算（一） - 敬渊&#39;s Blog</title><meta name="author" content="">
<meta name="description" content="核心摘要 (Key Takeaways) V3手续费的复杂性根源：与V2的全范围流动性不同，Uniswap V3的集中流动性允许LP在自定义价格区间（ticks）提供流动性，这使得手续费的计算和分配变得极其复杂。 全局手续费累加器 feeGrowthGlobal：Uniswap V3引入了一个全局状态变量 feeGrowthGlobal，它代表每单位流动性可以获得的总手续费。这个值会随着每笔交易单调递增。 手续费按token in收取：手续费只对交易中“进入”池子的代币收取。因此，系统需要为交易对中的两种代币（token0 和 token1）分别维护两个独立的feeGrowthGlobal变量，导致其增长呈现阶梯状。 LP的核心关注点 feeGrowthInside：LP只关心在其提供的流动性区间内产生的手су费。因此，需要从全局feeGrowthGlobal中剥离掉区间外的部分，得到feeGrowthInside。 精巧的边界记录机制 feeGrowthOutside：V3通过在每个tick边界上记录一个名为feeGrowthOutside的值，来巧妙地计算任意区间的feeGrowthInside。当价格穿越一个tick时，该tick的feeGrowthOutside值会被更新，从而精确追踪内外手续费的累积情况。 1. Uniswap V2 vs. V3 手续费机制对比 1.1 Uniswap V2：简单直接 流动性模型：流动性平均分布在从 0 到 &#43;∞ 的整个价格曲线上。 手续费收取： 对每笔交易收取固定的千分之三（0.3%）手续费。 手续费只对 token in （交易中流入池子的代币）收取。 案例： 用 X 换 Y：收取 0.003 * X，实际用于交易的是 0.997 * X。 用 Y 换 X：收取 0.003 * Y，实际用于交易的是 0.997 * Y。 手续费分配：收取的手续费会自动累积到流动性池中，为LP实现自动复投增值，无需任何额外操作。 1.2 Uniswap V3：挑战重重 核心挑战：集中流动性 (Concentrated Liquidity)。 不同的LP可以在不同的价格区间（由tick lower和tick upper定义，视频中也称为PA和PB）提供流动性。 手续费档位：V3提供了多个手续费档位供流动性池选择，如 0.01%, 0.05%, 0.3%, 1%。 需要解决的问题： 按比例分配：在同一个tick区间内，手续费需按LP提供的流动性比例进行分配。 跨tick计算：当交易价格跨越tick边界，导致总流动性发生变化时，如何精确计算每个LP在其活跃区间内应得的手续费。 2. 手续费分配的基本原理与 feeGrowth 的引入 2.1 单次交易的分配逻辑 核心思想：LP在某个价格区间获得的手续费，等于该区间产生的总手续费乘以该LP提供的流动性占比。 案例：单次跨tick交易 背景： 一个LP在某个范围内提供了流动性，大小为 S。 一笔交易发生，使得价格从tick_0移动到tick_1。 在$tick_0$区间的总流动性为$L_0$，产生的总手续费为$F_0$。 在tick_1区间的总流动性为$L_1$，产生的总手续费为$F_1$。 计算LP应得手续费：该LP获得的手续费 $Fee_S$ 是其在每个tick区间所获手续费的总和。 $$ Fee_S = \left(F_0 \cdot \frac{S}{L_0}\right) &#43; \left(F_1 \cdot \frac{S}{L_1}\right) $$ 2.2 feeGrowthGlobal：全局手续费累加器 概念推导：将上述逻辑扩展到 N 次交易，LP的总手续费可以表示为： $$ Fee_S = S \cdot \sum_{i=0}^{N} \frac{F_i}{L_i} $$ 定义：Uniswap V3将公式中求和的部分 $\sum_{i=0}^{N} \frac{F_i}{L_i}$ 定义为一个全局变量，称为 feeGrowthGlobal (视频中简称为FG)。 物理含义：feeGrowthGlobal 代表从系统部署开始，每单位流动性 (S=1) 累计可以获得的总手续费。 简化公式：LP的总手续费 $Fee_S = S \cdot feeGrowthGlobal$。 核心特性： 全局状态：feeGrowthGlobal 是一个存储在合约中的全局变量，随每次交易更新。 单调递增：只要有交易发生，feeGrowthGlobal 的值就会不断累积，永远不会减少。 按代币分离：由于手续费只对 token in 收取，因此合约为交易对中的两个代币分别维护了两个feeGrowthGlobal变量： **feeGrowthGlobal0** (针对 token0) **feeGrowthGlobal1** (针对 token1) 阶梯式增长： 当价格上涨时（例如，用token0换token1），feeGrowthGlobal0会增加，而feeGrowthGlobal1保持不变（呈水平线）。 当价格下跌时（例如，用token1换token0），feeGrowthGlobal1会增加，而feeGrowthGlobal0保持不变。 这导致每个feeGrowthGlobal变量的增长曲线都呈现出阶梯状。 3. 从全局到局部：计算 feeGrowthInside LP的视角：一个在特定价格区间 $[i_l, i_u]$ (tick lower, tick upper) 提供流动性的LP，只关心在这个区间内（inside）累积的手续费，区间外（outside）的与他无关。 核心概念： feeGrowthInside：在LP指定的 $[i_l, i_u]$ 区间内累积的每单位流动性手续费。 feeGrowthOutside：在该区间之外累积的手续费。 计算逻辑：feeGrowthInside 等于全局的 feeGrowthGlobal 减去所有在区间之外累积的部分。 白皮书与视频中的公式 (变量名来自视频讲解)： $$ F_{R(i_l, i_u)} = F_g - F_{B(i_l)} - F_{A(i_u)} $$ 公式解读： $F_{R(i_l, i_u)}$：我们想求的 feeGrowthInside (Range Fee)。 $F_g$：当前的全局 feeGrowthGlobal。 $F_{B(i_l)}$：所有低于下边界 $i_l$ 的手续费累积 (Fee Below)。 $F_{A(i_u)}$：所有高于上边界 $i_u$ 的手续费累积 (Fee Above)。 4. feeGrowthOutside：精巧的边界状态记录机制 为了高效计算任意区间的$F_{B(i_l)}$和$F_{A(i_u)}$，V3合约并不直接记录它们，而是采用了一个更巧妙的机制：在每个被激活的tick上记录一个状态变量 **feeGrowthOutside** (视频中简称为$F_{O(i)}$)。
"><meta name="keywords" content='Web3'>
  <meta itemprop="name" content="18.Uniswap V3 手续费计算（一）">
  <meta itemprop="description" content="核心摘要 (Key Takeaways) V3手续费的复杂性根源：与V2的全范围流动性不同，Uniswap V3的集中流动性允许LP在自定义价格区间（ticks）提供流动性，这使得手续费的计算和分配变得极其复杂。 全局手续费累加器 feeGrowthGlobal：Uniswap V3引入了一个全局状态变量 feeGrowthGlobal，它代表每单位流动性可以获得的总手续费。这个值会随着每笔交易单调递增。 手续费按token in收取：手续费只对交易中“进入”池子的代币收取。因此，系统需要为交易对中的两种代币（token0 和 token1）分别维护两个独立的feeGrowthGlobal变量，导致其增长呈现阶梯状。 LP的核心关注点 feeGrowthInside：LP只关心在其提供的流动性区间内产生的手су费。因此，需要从全局feeGrowthGlobal中剥离掉区间外的部分，得到feeGrowthInside。 精巧的边界记录机制 feeGrowthOutside：V3通过在每个tick边界上记录一个名为feeGrowthOutside的值，来巧妙地计算任意区间的feeGrowthInside。当价格穿越一个tick时，该tick的feeGrowthOutside值会被更新，从而精确追踪内外手续费的累积情况。 1. Uniswap V2 vs. V3 手续费机制对比 1.1 Uniswap V2：简单直接 流动性模型：流动性平均分布在从 0 到 &#43;∞ 的整个价格曲线上。 手续费收取： 对每笔交易收取固定的千分之三（0.3%）手续费。 手续费只对 token in （交易中流入池子的代币）收取。 案例： 用 X 换 Y：收取 0.003 * X，实际用于交易的是 0.997 * X。 用 Y 换 X：收取 0.003 * Y，实际用于交易的是 0.997 * Y。 手续费分配：收取的手续费会自动累积到流动性池中，为LP实现自动复投增值，无需任何额外操作。 1.2 Uniswap V3：挑战重重 核心挑战：集中流动性 (Concentrated Liquidity)。 不同的LP可以在不同的价格区间（由tick lower和tick upper定义，视频中也称为PA和PB）提供流动性。 手续费档位：V3提供了多个手续费档位供流动性池选择，如 0.01%, 0.05%, 0.3%, 1%。 需要解决的问题： 按比例分配：在同一个tick区间内，手续费需按LP提供的流动性比例进行分配。 跨tick计算：当交易价格跨越tick边界，导致总流动性发生变化时，如何精确计算每个LP在其活跃区间内应得的手续费。 2. 手续费分配的基本原理与 feeGrowth 的引入 2.1 单次交易的分配逻辑 核心思想：LP在某个价格区间获得的手续费，等于该区间产生的总手续费乘以该LP提供的流动性占比。 案例：单次跨tick交易 背景： 一个LP在某个范围内提供了流动性，大小为 S。 一笔交易发生，使得价格从tick_0移动到tick_1。 在$tick_0$区间的总流动性为$L_0$，产生的总手续费为$F_0$。 在tick_1区间的总流动性为$L_1$，产生的总手续费为$F_1$。 计算LP应得手续费：该LP获得的手续费 $Fee_S$ 是其在每个tick区间所获手续费的总和。 $$ Fee_S = \left(F_0 \cdot \frac{S}{L_0}\right) &#43; \left(F_1 \cdot \frac{S}{L_1}\right) $$ 2.2 feeGrowthGlobal：全局手续费累加器 概念推导：将上述逻辑扩展到 N 次交易，LP的总手续费可以表示为： $$ Fee_S = S \cdot \sum_{i=0}^{N} \frac{F_i}{L_i} $$ 定义：Uniswap V3将公式中求和的部分 $\sum_{i=0}^{N} \frac{F_i}{L_i}$ 定义为一个全局变量，称为 feeGrowthGlobal (视频中简称为FG)。 物理含义：feeGrowthGlobal 代表从系统部署开始，每单位流动性 (S=1) 累计可以获得的总手续费。 简化公式：LP的总手续费 $Fee_S = S \cdot feeGrowthGlobal$。 核心特性： 全局状态：feeGrowthGlobal 是一个存储在合约中的全局变量，随每次交易更新。 单调递增：只要有交易发生，feeGrowthGlobal 的值就会不断累积，永远不会减少。 按代币分离：由于手续费只对 token in 收取，因此合约为交易对中的两个代币分别维护了两个feeGrowthGlobal变量： **feeGrowthGlobal0** (针对 token0) **feeGrowthGlobal1** (针对 token1) 阶梯式增长： 当价格上涨时（例如，用token0换token1），feeGrowthGlobal0会增加，而feeGrowthGlobal1保持不变（呈水平线）。 当价格下跌时（例如，用token1换token0），feeGrowthGlobal1会增加，而feeGrowthGlobal0保持不变。 这导致每个feeGrowthGlobal变量的增长曲线都呈现出阶梯状。 3. 从全局到局部：计算 feeGrowthInside LP的视角：一个在特定价格区间 $[i_l, i_u]$ (tick lower, tick upper) 提供流动性的LP，只关心在这个区间内（inside）累积的手续费，区间外（outside）的与他无关。 核心概念： feeGrowthInside：在LP指定的 $[i_l, i_u]$ 区间内累积的每单位流动性手续费。 feeGrowthOutside：在该区间之外累积的手续费。 计算逻辑：feeGrowthInside 等于全局的 feeGrowthGlobal 减去所有在区间之外累积的部分。 白皮书与视频中的公式 (变量名来自视频讲解)： $$ F_{R(i_l, i_u)} = F_g - F_{B(i_l)} - F_{A(i_u)} $$ 公式解读： $F_{R(i_l, i_u)}$：我们想求的 feeGrowthInside (Range Fee)。 $F_g$：当前的全局 feeGrowthGlobal。 $F_{B(i_l)}$：所有低于下边界 $i_l$ 的手续费累积 (Fee Below)。 $F_{A(i_u)}$：所有高于上边界 $i_u$ 的手续费累积 (Fee Above)。 4. feeGrowthOutside：精巧的边界状态记录机制 为了高效计算任意区间的$F_{B(i_l)}$和$F_{A(i_u)}$，V3合约并不直接记录它们，而是采用了一个更巧妙的机制：在每个被激活的tick上记录一个状态变量 **feeGrowthOutside** (视频中简称为$F_{O(i)}$)。">
  <meta itemprop="datePublished" content="2025-09-02T00:00:00+00:00">
  <meta itemprop="dateModified" content="2025-09-02T00:00:00+00:00">
  <meta itemprop="wordCount" content="3954">
  <meta itemprop="keywords" content="Web3"><meta property="og:url" content="https://nesl42.github.io/posts/202509-uniswap18/">
  <meta property="og:site_name" content="敬渊&#39;s Blog">
  <meta property="og:title" content="18.Uniswap V3 手续费计算（一）">
  <meta property="og:description" content="核心摘要 (Key Takeaways) V3手续费的复杂性根源：与V2的全范围流动性不同，Uniswap V3的集中流动性允许LP在自定义价格区间（ticks）提供流动性，这使得手续费的计算和分配变得极其复杂。 全局手续费累加器 feeGrowthGlobal：Uniswap V3引入了一个全局状态变量 feeGrowthGlobal，它代表每单位流动性可以获得的总手续费。这个值会随着每笔交易单调递增。 手续费按token in收取：手续费只对交易中“进入”池子的代币收取。因此，系统需要为交易对中的两种代币（token0 和 token1）分别维护两个独立的feeGrowthGlobal变量，导致其增长呈现阶梯状。 LP的核心关注点 feeGrowthInside：LP只关心在其提供的流动性区间内产生的手су费。因此，需要从全局feeGrowthGlobal中剥离掉区间外的部分，得到feeGrowthInside。 精巧的边界记录机制 feeGrowthOutside：V3通过在每个tick边界上记录一个名为feeGrowthOutside的值，来巧妙地计算任意区间的feeGrowthInside。当价格穿越一个tick时，该tick的feeGrowthOutside值会被更新，从而精确追踪内外手续费的累积情况。 1. Uniswap V2 vs. V3 手续费机制对比 1.1 Uniswap V2：简单直接 流动性模型：流动性平均分布在从 0 到 &#43;∞ 的整个价格曲线上。 手续费收取： 对每笔交易收取固定的千分之三（0.3%）手续费。 手续费只对 token in （交易中流入池子的代币）收取。 案例： 用 X 换 Y：收取 0.003 * X，实际用于交易的是 0.997 * X。 用 Y 换 X：收取 0.003 * Y，实际用于交易的是 0.997 * Y。 手续费分配：收取的手续费会自动累积到流动性池中，为LP实现自动复投增值，无需任何额外操作。 1.2 Uniswap V3：挑战重重 核心挑战：集中流动性 (Concentrated Liquidity)。 不同的LP可以在不同的价格区间（由tick lower和tick upper定义，视频中也称为PA和PB）提供流动性。 手续费档位：V3提供了多个手续费档位供流动性池选择，如 0.01%, 0.05%, 0.3%, 1%。 需要解决的问题： 按比例分配：在同一个tick区间内，手续费需按LP提供的流动性比例进行分配。 跨tick计算：当交易价格跨越tick边界，导致总流动性发生变化时，如何精确计算每个LP在其活跃区间内应得的手续费。 2. 手续费分配的基本原理与 feeGrowth 的引入 2.1 单次交易的分配逻辑 核心思想：LP在某个价格区间获得的手续费，等于该区间产生的总手续费乘以该LP提供的流动性占比。 案例：单次跨tick交易 背景： 一个LP在某个范围内提供了流动性，大小为 S。 一笔交易发生，使得价格从tick_0移动到tick_1。 在$tick_0$区间的总流动性为$L_0$，产生的总手续费为$F_0$。 在tick_1区间的总流动性为$L_1$，产生的总手续费为$F_1$。 计算LP应得手续费：该LP获得的手续费 $Fee_S$ 是其在每个tick区间所获手续费的总和。 $$ Fee_S = \left(F_0 \cdot \frac{S}{L_0}\right) &#43; \left(F_1 \cdot \frac{S}{L_1}\right) $$ 2.2 feeGrowthGlobal：全局手续费累加器 概念推导：将上述逻辑扩展到 N 次交易，LP的总手续费可以表示为： $$ Fee_S = S \cdot \sum_{i=0}^{N} \frac{F_i}{L_i} $$ 定义：Uniswap V3将公式中求和的部分 $\sum_{i=0}^{N} \frac{F_i}{L_i}$ 定义为一个全局变量，称为 feeGrowthGlobal (视频中简称为FG)。 物理含义：feeGrowthGlobal 代表从系统部署开始，每单位流动性 (S=1) 累计可以获得的总手续费。 简化公式：LP的总手续费 $Fee_S = S \cdot feeGrowthGlobal$。 核心特性： 全局状态：feeGrowthGlobal 是一个存储在合约中的全局变量，随每次交易更新。 单调递增：只要有交易发生，feeGrowthGlobal 的值就会不断累积，永远不会减少。 按代币分离：由于手续费只对 token in 收取，因此合约为交易对中的两个代币分别维护了两个feeGrowthGlobal变量： **feeGrowthGlobal0** (针对 token0) **feeGrowthGlobal1** (针对 token1) 阶梯式增长： 当价格上涨时（例如，用token0换token1），feeGrowthGlobal0会增加，而feeGrowthGlobal1保持不变（呈水平线）。 当价格下跌时（例如，用token1换token0），feeGrowthGlobal1会增加，而feeGrowthGlobal0保持不变。 这导致每个feeGrowthGlobal变量的增长曲线都呈现出阶梯状。 3. 从全局到局部：计算 feeGrowthInside LP的视角：一个在特定价格区间 $[i_l, i_u]$ (tick lower, tick upper) 提供流动性的LP，只关心在这个区间内（inside）累积的手续费，区间外（outside）的与他无关。 核心概念： feeGrowthInside：在LP指定的 $[i_l, i_u]$ 区间内累积的每单位流动性手续费。 feeGrowthOutside：在该区间之外累积的手续费。 计算逻辑：feeGrowthInside 等于全局的 feeGrowthGlobal 减去所有在区间之外累积的部分。 白皮书与视频中的公式 (变量名来自视频讲解)： $$ F_{R(i_l, i_u)} = F_g - F_{B(i_l)} - F_{A(i_u)} $$ 公式解读： $F_{R(i_l, i_u)}$：我们想求的 feeGrowthInside (Range Fee)。 $F_g$：当前的全局 feeGrowthGlobal。 $F_{B(i_l)}$：所有低于下边界 $i_l$ 的手续费累积 (Fee Below)。 $F_{A(i_u)}$：所有高于上边界 $i_u$ 的手续费累积 (Fee Above)。 4. feeGrowthOutside：精巧的边界状态记录机制 为了高效计算任意区间的$F_{B(i_l)}$和$F_{A(i_u)}$，V3合约并不直接记录它们，而是采用了一个更巧妙的机制：在每个被激活的tick上记录一个状态变量 **feeGrowthOutside** (视频中简称为$F_{O(i)}$)。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-09-02T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-09-02T00:00:00+00:00">
    <meta property="article:tag" content="Web3">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="18.Uniswap V3 手续费计算（一）">
  <meta name="twitter:description" content="核心摘要 (Key Takeaways) V3手续费的复杂性根源：与V2的全范围流动性不同，Uniswap V3的集中流动性允许LP在自定义价格区间（ticks）提供流动性，这使得手续费的计算和分配变得极其复杂。 全局手续费累加器 feeGrowthGlobal：Uniswap V3引入了一个全局状态变量 feeGrowthGlobal，它代表每单位流动性可以获得的总手续费。这个值会随着每笔交易单调递增。 手续费按token in收取：手续费只对交易中“进入”池子的代币收取。因此，系统需要为交易对中的两种代币（token0 和 token1）分别维护两个独立的feeGrowthGlobal变量，导致其增长呈现阶梯状。 LP的核心关注点 feeGrowthInside：LP只关心在其提供的流动性区间内产生的手су费。因此，需要从全局feeGrowthGlobal中剥离掉区间外的部分，得到feeGrowthInside。 精巧的边界记录机制 feeGrowthOutside：V3通过在每个tick边界上记录一个名为feeGrowthOutside的值，来巧妙地计算任意区间的feeGrowthInside。当价格穿越一个tick时，该tick的feeGrowthOutside值会被更新，从而精确追踪内外手续费的累积情况。 1. Uniswap V2 vs. V3 手续费机制对比 1.1 Uniswap V2：简单直接 流动性模型：流动性平均分布在从 0 到 &#43;∞ 的整个价格曲线上。 手续费收取： 对每笔交易收取固定的千分之三（0.3%）手续费。 手续费只对 token in （交易中流入池子的代币）收取。 案例： 用 X 换 Y：收取 0.003 * X，实际用于交易的是 0.997 * X。 用 Y 换 X：收取 0.003 * Y，实际用于交易的是 0.997 * Y。 手续费分配：收取的手续费会自动累积到流动性池中，为LP实现自动复投增值，无需任何额外操作。 1.2 Uniswap V3：挑战重重 核心挑战：集中流动性 (Concentrated Liquidity)。 不同的LP可以在不同的价格区间（由tick lower和tick upper定义，视频中也称为PA和PB）提供流动性。 手续费档位：V3提供了多个手续费档位供流动性池选择，如 0.01%, 0.05%, 0.3%, 1%。 需要解决的问题： 按比例分配：在同一个tick区间内，手续费需按LP提供的流动性比例进行分配。 跨tick计算：当交易价格跨越tick边界，导致总流动性发生变化时，如何精确计算每个LP在其活跃区间内应得的手续费。 2. 手续费分配的基本原理与 feeGrowth 的引入 2.1 单次交易的分配逻辑 核心思想：LP在某个价格区间获得的手续费，等于该区间产生的总手续费乘以该LP提供的流动性占比。 案例：单次跨tick交易 背景： 一个LP在某个范围内提供了流动性，大小为 S。 一笔交易发生，使得价格从tick_0移动到tick_1。 在$tick_0$区间的总流动性为$L_0$，产生的总手续费为$F_0$。 在tick_1区间的总流动性为$L_1$，产生的总手续费为$F_1$。 计算LP应得手续费：该LP获得的手续费 $Fee_S$ 是其在每个tick区间所获手续费的总和。 $$ Fee_S = \left(F_0 \cdot \frac{S}{L_0}\right) &#43; \left(F_1 \cdot \frac{S}{L_1}\right) $$ 2.2 feeGrowthGlobal：全局手续费累加器 概念推导：将上述逻辑扩展到 N 次交易，LP的总手续费可以表示为： $$ Fee_S = S \cdot \sum_{i=0}^{N} \frac{F_i}{L_i} $$ 定义：Uniswap V3将公式中求和的部分 $\sum_{i=0}^{N} \frac{F_i}{L_i}$ 定义为一个全局变量，称为 feeGrowthGlobal (视频中简称为FG)。 物理含义：feeGrowthGlobal 代表从系统部署开始，每单位流动性 (S=1) 累计可以获得的总手续费。 简化公式：LP的总手续费 $Fee_S = S \cdot feeGrowthGlobal$。 核心特性： 全局状态：feeGrowthGlobal 是一个存储在合约中的全局变量，随每次交易更新。 单调递增：只要有交易发生，feeGrowthGlobal 的值就会不断累积，永远不会减少。 按代币分离：由于手续费只对 token in 收取，因此合约为交易对中的两个代币分别维护了两个feeGrowthGlobal变量： **feeGrowthGlobal0** (针对 token0) **feeGrowthGlobal1** (针对 token1) 阶梯式增长： 当价格上涨时（例如，用token0换token1），feeGrowthGlobal0会增加，而feeGrowthGlobal1保持不变（呈水平线）。 当价格下跌时（例如，用token1换token0），feeGrowthGlobal1会增加，而feeGrowthGlobal0保持不变。 这导致每个feeGrowthGlobal变量的增长曲线都呈现出阶梯状。 3. 从全局到局部：计算 feeGrowthInside LP的视角：一个在特定价格区间 $[i_l, i_u]$ (tick lower, tick upper) 提供流动性的LP，只关心在这个区间内（inside）累积的手续费，区间外（outside）的与他无关。 核心概念： feeGrowthInside：在LP指定的 $[i_l, i_u]$ 区间内累积的每单位流动性手续费。 feeGrowthOutside：在该区间之外累积的手续费。 计算逻辑：feeGrowthInside 等于全局的 feeGrowthGlobal 减去所有在区间之外累积的部分。 白皮书与视频中的公式 (变量名来自视频讲解)： $$ F_{R(i_l, i_u)} = F_g - F_{B(i_l)} - F_{A(i_u)} $$ 公式解读： $F_{R(i_l, i_u)}$：我们想求的 feeGrowthInside (Range Fee)。 $F_g$：当前的全局 feeGrowthGlobal。 $F_{B(i_l)}$：所有低于下边界 $i_l$ 的手续费累积 (Fee Below)。 $F_{A(i_u)}$：所有高于上边界 $i_u$ 的手续费累积 (Fee Above)。 4. feeGrowthOutside：精巧的边界状态记录机制 为了高效计算任意区间的$F_{B(i_l)}$和$F_{A(i_u)}$，V3合约并不直接记录它们，而是采用了一个更巧妙的机制：在每个被激活的tick上记录一个状态变量 **feeGrowthOutside** (视频中简称为$F_{O(i)}$)。">
<meta name="application-name" content="FixIt">
<meta name="apple-mobile-web-app-title" content="FixIt"><meta name="theme-color" data-light="#f8f8f8" data-dark="#252627" content="#f8f8f8"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="canonical" type="text/html" href="https://nesl42.github.io/posts/202509-uniswap18/" title="18.Uniswap V3 手续费计算（一） - 敬渊&#39;s Blog" /><link rel="prev" type="text/html" href="https://nesl42.github.io/posts/202509-uniswap19/" title="19.Uniswap V3 手续费计算（二）" /><link rel="next" type="text/html" href="https://nesl42.github.io/posts/202509-uniswap16/" title="16.Uniswap V3 LiquidityNet" /><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="/lib/fontawesome-free/all.min.css" as="style" onload="this.removeAttribute('onload');this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"></noscript><link rel="preload" href="/lib/animate/animate.min.css" as="style" onload="this.removeAttribute('onload');this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="/lib/animate/animate.min.css"></noscript><script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "headline": "18.Uniswap V3 手续费计算（一）",
    "inLanguage": "zh-CN",
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "https:\/\/nesl42.github.io\/posts\/202509-uniswap18\/"
    },"genre": "posts","keywords": "Web3","wordcount":  3954 ,
    "url": "https:\/\/nesl42.github.io\/posts\/202509-uniswap18\/","datePublished": "2025-09-02T00:00:00+00:00","dateModified": "2025-09-02T00:00:00+00:00","publisher": {
      "@type": "Organization",
      "name": ""},"author": {
        "@type": "Person",
        "name": "Author"
      },"description": ""
  }
  </script><script src="/js/head/color-scheme.min.js"></script></head>
  <body data-header-desktop="sticky" data-header-mobile="auto"><div class="wrapper" data-page-style="normal"><header class="desktop animate__faster" id="header-desktop">
  <div class="header-wrapper">
    <div class="header-title">
      <a href="/" title="敬渊&#39;s Blog"><span class="header-title-text">敬渊&#39;s Blog</span></a><span class="header-subtitle"></span></div>
    <nav>
      <ul class="menu"><li class="menu-item">
              <a class="menu-link" href="/posts/">文章</a></li><li class="menu-item">
              <a class="menu-link" href="/tags/">标签</a></li><li class="menu-item">
              <a class="menu-link" href="/about/">关于</a></li><li class="menu-item">
              <a class="menu-link" href="/categories/">分类</a></li><li class="menu-item delimiter"></li><li class="menu-item theme-switch" title="Switch Theme">
          <i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i>
        </li></ul>
    </nav>
  </div>
</header><header class="mobile animate__faster" id="header-mobile">
  <div class="header-container">
    <div class="header-wrapper">
      <div class="header-title">
        <a href="/" title="敬渊&#39;s Blog"><span class="header-title-text">敬渊&#39;s Blog</span></a><span class="header-subtitle"></span></div>
      <div class="menu-toggle" id="menu-toggle-mobile">
        <span></span><span></span><span></span>
      </div>
    </div>
    <nav>
      <ul class="menu" id="menu-mobile"><li class="menu-item"><a class="menu-link" href="/posts/">文章</a></li><li class="menu-item"><a class="menu-link" href="/tags/">标签</a></li><li class="menu-item"><a class="menu-link" href="/about/">关于</a></li><li class="menu-item"><a class="menu-link" href="/categories/">分类</a></li><li class="menu-item menu-system">
          <span class="menu-system-item theme-switch" title="Switch Theme"><i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i></span></li>
      </ul>
    </nav>
  </div>
</header><main class="container"><aside class="aside-collection animate__animated animate__fadeIn animate__faster" aria-label="Collections"></aside>

  <article class="page single">
    <div class="header"><h1 class="single-title animate__animated animate__flipInX"><span>18.Uniswap V3 手续费计算（一）</span>
      </h1></div><div class="post-meta">
      <div class="post-meta-line"><span class="post-author"><span class="author"><i class="fa-solid fa-user-circle" aria-hidden="true"></i>
      Anonymous</span></span><span class="post-included-in">&nbsp;included in <a href="/categories/technology/" class="post-category" title="Category - Technology"><i class="fa-regular fa-folder fa-fw" aria-hidden="true"></i> Technology</a></span></div><div class="post-meta-line"><span title="published on 2025-09-02 00:00:00"><i class="fa-solid fa-calendar-days fa-fw me-1" aria-hidden="true"></i><time datetime="2025-09-02">2025-09-02</time></span>&nbsp;<span title="3954 words"><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden="true"></i>About 4000 words</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden="true"></i>8 minutes</span>&nbsp;</div>
    </div><div class="details toc" id="toc-static" data-kept="false">
        <div class="details-summary toc-title">
          <span>Contents</span>
          <span><i class="details-icon fa-solid fa-angle-right" aria-hidden="true"></i></span>
        </div>
        <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li>
          <ul>
            <li><a href="#核心摘要-key-takeaways"><strong>核心摘要 (Key Takeaways)</strong></a></li>
            <li><a href="#1-uniswap-v2-vs-v3-手续费机制对比"><strong>1. Uniswap V2 vs. V3 手续费机制对比</strong></a>
              <ul>
                <li><a href="#11-uniswap-v2简单直接"><strong>1.1 Uniswap V2：简单直接</strong></a></li>
                <li><a href="#12-uniswap-v3挑战重重"><strong>1.2 Uniswap V3：挑战重重</strong></a></li>
              </ul>
            </li>
            <li><a href="#2-手续费分配的基本原理与"><strong>2. 手续费分配的基本原理与 <code>feeGrowth</code> 的引入</strong></a>
              <ul>
                <li><a href="#21-单次交易的分配逻辑"><strong>2.1 单次交易的分配逻辑</strong></a></li>
                <li><a href="#22"><strong>2.2 <code>feeGrowthGlobal</code>：全局手续费累加器</strong></a></li>
              </ul>
            </li>
            <li><a href="#3-从全局到局部计算"><strong>3. 从全局到局部：计算 <code>feeGrowthInside</code></strong></a></li>
            <li><a href="#4"><strong>4. <code>feeGrowthOutside</code>：精巧的边界状态记录机制</strong></a>
              <ul>
                <li><a href="#41"><strong>4.1 <code>feeGrowthOutside</code> 的初始化</strong></a></li>
                <li><a href="#42"><strong>4.2 <code>feeGrowthOutside</code> 的更新</strong></a></li>
              </ul>
            </li>
            <li><a href="#5-场景推演"><strong>5. 场景推演：<code>feeGrowthInside</code> 的计算过程</strong></a>
              <ul>
                <li><a href="#51-可视化流程图-mermaid-diagram"><strong>5.1 可视化流程图 (Mermaid Diagram)</strong></a></li>
                <li><a href="#52-具体计算案例"><strong>5.2 具体计算案例</strong></a></li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav></div>
      </div><div class="content" id="content"><h3 id="核心摘要-key-takeaways" class="heading-element"><span><strong>核心摘要 (Key Takeaways)</strong></span>
  <a href="#%e6%a0%b8%e5%bf%83%e6%91%98%e8%a6%81-key-takeaways" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li><strong>V3手续费的复杂性根源</strong>：与V2的全范围流动性不同，Uniswap V3的<strong>集中流动性</strong>允许LP在自定义价格区间（<code>ticks</code>）提供流动性，这使得手续费的计算和分配变得极其复杂。</li>
<li><strong>全局手续费累加器 <code>feeGrowthGlobal</code></strong>：Uniswap V3引入了一个全局状态变量 <code>feeGrowthGlobal</code>，它代表<strong>每单位流动性</strong>可以获得的总手续费。这个值会随着每笔交易单调递增。</li>
<li><strong>手续费按<code>token in</code>收取</strong>：手续费只对交易中“进入”池子的代币收取。因此，系统需要为交易对中的两种代币（<code>token0</code> 和 <code>token1</code>）分别维护两个独立的<code>feeGrowthGlobal</code>变量，导致其增长呈现阶梯状。</li>
<li><strong>LP的核心关注点 <code>feeGrowthInside</code></strong>：LP只关心在其提供的流动性区间内产生的手су费。因此，需要从全局<code>feeGrowthGlobal</code>中剥离掉区间外的部分，得到<code>feeGrowthInside</code>。</li>
<li><strong>精巧的边界记录机制 <code>feeGrowthOutside</code></strong>：V3通过在每个<code>tick</code>边界上记录一个名为<code>feeGrowthOutside</code>的值，来巧妙地计算任意区间的<code>feeGrowthInside</code>。当价格穿越一个<code>tick</code>时，该<code>tick</code>的<code>feeGrowthOutside</code>值会被更新，从而精确追踪内外手续费的累积情况。</li>
</ul>
<h3 id="1-uniswap-v2-vs-v3-手续费机制对比" class="heading-element"><span><strong>1. Uniswap V2 vs. V3 手续费机制对比</strong></span>
  <a href="#1-uniswap-v2-vs-v3-%e6%89%8b%e7%bb%ad%e8%b4%b9%e6%9c%ba%e5%88%b6%e5%af%b9%e6%af%94" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><h4 id="11-uniswap-v2简单直接" class="heading-element"><span><strong>1.1 Uniswap V2：简单直接</strong></span>
  <a href="#11-uniswap-v2%e7%ae%80%e5%8d%95%e7%9b%b4%e6%8e%a5" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><ul>
<li><strong>流动性模型</strong>：流动性平均分布在从 <code>0</code> 到 <code>+∞</code> 的整个价格曲线上。</li>
<li><strong>手续费收取</strong>：
<ul>
<li>对每笔交易收取固定的千分之三（0.3%）手续费。</li>
<li>手续费只对 <strong><code>token in</code></strong> （交易中流入池子的代币）收取。</li>
<li><strong>案例</strong>：
<ul>
<li>用 X 换 Y：收取 <code>0.003 * X</code>，实际用于交易的是 <code>0.997 * X</code>。</li>
<li>用 Y 换 X：收取 <code>0.003 * Y</code>，实际用于交易的是 <code>0.997 * Y</code>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>手续费分配</strong>：收取的手续费会自动累积到流动性池中，为LP实现<strong>自动复投</strong>增值，无需任何额外操作。</li>
</ul>
<h4 id="12-uniswap-v3挑战重重" class="heading-element"><span><strong>1.2 Uniswap V3：挑战重重</strong></span>
  <a href="#12-uniswap-v3%e6%8c%91%e6%88%98%e9%87%8d%e9%87%8d" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><ul>
<li><strong>核心挑战</strong>：<strong>集中流动性 (Concentrated Liquidity)</strong>。
<ul>
<li>不同的LP可以在<strong>不同的价格区间</strong>（由<code>tick lower</code>和<code>tick upper</code>定义，视频中也称为<code>PA</code>和<code>PB</code>）提供流动性。</li>
<li><strong>手续费档位</strong>：V3提供了多个手续费档位供流动性池选择，如 <code>0.01%</code>, <code>0.05%</code>, <code>0.3%</code>, <code>1%</code>。</li>
</ul>
</li>
<li><strong>需要解决的问题</strong>：
<ol>
<li><strong>按比例分配</strong>：在同一个<code>tick</code>区间内，手续费需按LP提供的流动性比例进行分配。</li>
<li><strong>跨<code>tick</code>计算</strong>：当交易价格跨越<code>tick</code>边界，导致总流动性发生变化时，如何精确计算每个LP在其活跃区间内应得的手续费。</li>
</ol>
</li>
</ul>
<h3 id="2-手续费分配的基本原理与" class="heading-element"><span><strong>2. 手续费分配的基本原理与 <code>feeGrowth</code> 的引入</strong></span>
  <a href="#2-%e6%89%8b%e7%bb%ad%e8%b4%b9%e5%88%86%e9%85%8d%e7%9a%84%e5%9f%ba%e6%9c%ac%e5%8e%9f%e7%90%86%e4%b8%8e" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><h4 id="21-单次交易的分配逻辑" class="heading-element"><span><strong>2.1 单次交易的分配逻辑</strong></span>
  <a href="#21-%e5%8d%95%e6%ac%a1%e4%ba%a4%e6%98%93%e7%9a%84%e5%88%86%e9%85%8d%e9%80%bb%e8%be%91" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><ul>
<li><strong>核心思想</strong>：LP在某个价格区间获得的手续费，等于该区间产生的<strong>总手续费</strong>乘以该LP提供的<strong>流动性占比</strong>。</li>
<li><strong>案例：单次跨<code>tick</code>交易</strong>
<ul>
<li><strong>背景</strong>：
<ul>
<li>一个LP在某个范围内提供了流动性，大小为 <code>S</code>。</li>
<li>一笔交易发生，使得价格从<code>tick_0</code>移动到<code>tick_1</code>。</li>
<li>在$tick_0$区间的总流动性为$L_0$，产生的总手续费为$F_0$。</li>
<li>在<code>tick_1</code>区间的总流动性为$L_1$，产生的总手续费为$F_1$。</li>
</ul>
</li>
<li><strong>计算LP应得手续费</strong>：该LP获得的手续费 $Fee_S$ 是其在每个<code>tick</code>区间所获手续费的总和。
$$
Fee_S = \left(F_0 \cdot \frac{S}{L_0}\right) + \left(F_1 \cdot \frac{S}{L_1}\right)
$$</li>
</ul>
</li>
</ul>
<h4 id="22" class="heading-element"><span><strong>2.2 <code>feeGrowthGlobal</code>：全局手续费累加器</strong></span>
  <a href="#22" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><ul>
<li><strong>概念推导</strong>：将上述逻辑扩展到 <code>N</code> 次交易，LP的总手续费可以表示为：
$$
Fee_S = S \cdot \sum_{i=0}^{N} \frac{F_i}{L_i}
$$</li>
<li><strong>定义</strong>：Uniswap V3将公式中求和的部分 $\sum_{i=0}^{N} \frac{F_i}{L_i}$ 定义为一个全局变量，称为 <strong><code>feeGrowthGlobal</code></strong> (视频中简称为<code>FG</code>)。
<ul>
<li><strong>物理含义</strong>：<code>feeGrowthGlobal</code> 代表从系统部署开始，<strong>每单位流动性 (<code>S=1</code>)</strong> 累计可以获得的总手续费。</li>
<li><strong>简化公式</strong>：LP的总手续费 $Fee_S = S \cdot feeGrowthGlobal$。</li>
</ul>
</li>
<li><strong>核心特性</strong>：
<ol>
<li><strong>全局状态</strong>：<code>feeGrowthGlobal</code> 是一个存储在合约中的全局变量，随每次交易更新。</li>
<li><strong>单调递增</strong>：只要有交易发生，<code>feeGrowthGlobal</code> 的值就会不断累积，永远不会减少。</li>
<li><strong>按代币分离</strong>：由于手续费只对 <strong><code>token in</code></strong> 收取，因此合约为交易对中的两个代币分别维护了两个<code>feeGrowthGlobal</code>变量：
<ul>
<li><code>**feeGrowthGlobal0**</code> (针对 <code>token0</code>)</li>
<li><code>**feeGrowthGlobal1**</code> (针对 <code>token1</code>)</li>
</ul>
</li>
<li><strong>阶梯式增长</strong>：
<ul>
<li>当价格上涨时（例如，用<code>token0</code>换<code>token1</code>），<code>feeGrowthGlobal0</code>会增加，而<code>feeGrowthGlobal1</code>保持不变（呈水平线）。</li>
<li>当价格下跌时（例如，用<code>token1</code>换<code>token0</code>），<code>feeGrowthGlobal1</code>会增加，而<code>feeGrowthGlobal0</code>保持不变。</li>
<li>这导致每个<code>feeGrowthGlobal</code>变量的增长曲线都呈现出<strong>阶梯状</strong>。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="3-从全局到局部计算" class="heading-element"><span><strong>3. 从全局到局部：计算 <code>feeGrowthInside</code></strong></span>
  <a href="#3-%e4%bb%8e%e5%85%a8%e5%b1%80%e5%88%b0%e5%b1%80%e9%83%a8%e8%ae%a1%e7%ae%97" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li><strong>LP的视角</strong>：一个在特定价格区间 $[i_l, i_u]$ (<code>tick lower</code>, <code>tick upper</code>) 提供流动性的LP，只关心在这个区间内（<code>inside</code>）累积的手续费，区间外（<code>outside</code>）的与他无关。</li>
<li><strong>核心概念</strong>：
<ul>
<li><strong>feeGrowthInside</strong>：在LP指定的 $[i_l, i_u]$ 区间内累积的每单位流动性手续费。</li>
<li><strong>feeGrowthOutside</strong>：在该区间之外累积的手续费。</li>
</ul>
</li>
<li><strong>计算逻辑</strong>：<code>feeGrowthInside</code> 等于全局的 <code>feeGrowthGlobal</code> 减去所有在区间之外累积的部分。
<ul>
<li><strong>白皮书与视频中的公式</strong> (变量名来自视频讲解)：
$$
F_{R(i_l, i_u)} = F_g - F_{B(i_l)} - F_{A(i_u)}
$$</li>
<li><strong>公式解读</strong>：
<ul>
<li>$F_{R(i_l, i_u)}$：我们想求的 <strong><code>feeGrowthInside</code></strong> (Range Fee)。</li>
<li>$F_g$：当前的全局 <strong><code>feeGrowthGlobal</code></strong>。</li>
<li>$F_{B(i_l)}$：所有<strong>低于</strong>下边界 $i_l$ 的手续费累积 (<code>Fee Below</code>)。</li>
<li>$F_{A(i_u)}$：所有<strong>高于</strong>上边界 $i_u$ 的手续费累积 (<code>Fee Above</code>)。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4" class="heading-element"><span><strong>4. <code>feeGrowthOutside</code>：精巧的边界状态记录机制</strong></span>
  <a href="#4" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>为了高效计算任意区间的$F_{B(i_l)}$和$F_{A(i_u)}$，V3合约并不直接记录它们，而是采用了一个更巧妙的机制：在<strong>每个被激活的<code>tick</code>上</strong>记录一个状态变量 <code>**feeGrowthOutside**</code> (视频中简称为$F_{O(i)}$)。</p>
<h4 id="41" class="heading-element"><span><strong>4.1 <code>feeGrowthOutside</code> 的初始化</strong></span>
  <a href="#41" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>当一个LP在当前价格$i_c$时，添加 $[i_l, i_u]$ 区间的流动性，其边界<code>tick</code>的<code>feeGrowthOutside</code>值会按以下规则初始化：</p>
<ul>
<li><strong>规则</strong>：
<ul>
<li>如果一个<code>tick</code> $i$ 的位置<strong>小于等于</strong>当前价格$i_c$ ($i \le i_c$)，则 $F_{O(i)} = F_g$ (设为当前的全局<code>feeGrowthGlobal</code>)。</li>
<li>如果<code>tick</code> $i$ 的位置<strong>大于</strong>当前价格$i_c$ ($i &gt; i_c$)，则 $F_{O(i)} = 0$。</li>
</ul>
</li>
<li><strong>逻辑解释</strong>：这个初始化的目的是记录“在我加入之前，已经累积了多少手续费”。对于低于当前价格的下边界$i_l$，它将所有历史手续费都记录为“外部”，因为这些都与该LP无关。</li>
</ul>
<h4 id="42" class="heading-element"><span><strong>4.2 <code>feeGrowthOutside</code> 的更新</strong></span>
  <a href="#42" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><ul>
<li><strong>触发时机</strong>：当交易价格<strong>穿越 (cross)</strong> 某个<code>tick</code> $i$ 时。</li>
<li><strong>更新规则</strong>：
$$
F_{O(i)<em>{\text{new}}} = F_g - F</em>{O(i)_{\text{old}}}
$$</li>
<li><strong>逻辑解释</strong>：这是一个巧妙的“翻转”操作。每次穿越边界时，合约会用<strong>穿越瞬间</strong>的全局$F_g$减去该边界上记录的旧$F_{O(i)}$值。这使得<code>feeGrowthOutside</code>能动态追踪边界内外的费用划分，从而可以方便地计算出任意区间的内部增长。</li>
</ul>
<h3 id="5-场景推演" class="heading-element"><span><strong>5. 场景推演：<code>feeGrowthInside</code> 的计算过程</strong></span>
  <a href="#5-%e5%9c%ba%e6%99%af%e6%8e%a8%e6%bc%94" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><h4 id="51-可视化流程图-mermaid-diagram" class="heading-element"><span><strong>5.1 可视化流程图 (Mermaid Diagram)</strong></span>
  <a href="#51-%e5%8f%af%e8%a7%86%e5%8c%96%e6%b5%81%e7%a8%8b%e5%9b%be-mermaid-diagram" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><pre class="mermaid">flowchart TD
    A[LP在 i_l, i_u 区间添加流动性] --> B[初始化边界值];
    B --> C[根据当前价格 i_c];
    C --> C1[若 i_l 小于等于 i_c, F_O(i_l) = F_g0];
    C --> C2[若 i_u 大于 i_c, F_O(i_u) = 0];
  
    subgraph " "
    direction LR
    C1 --> D;
    C2 --> D;
    end

    D[交易发生, 价格变动] --> E{价格是否穿越边界?};
  
    E -- 否, 在区间内变动 --> F[feeGrowthInside = 当前F_g - F_g0];
  
    E -- 是 --> H{穿越哪个边界?};
    H -- 向右穿越 i_u --> I[更新 F_O(i_u) = F_g1 - F_O(i_u)_old];
    I --> J[feeGrowthInside = F_g1 - F_g0];
  
    H -- 向左穿越 i_l --> K[更新 F_O(i_l) = F_g1 - F_O(i_l)_old];
    K --> L[feeGrowthInside = F_g1 - F_g0];

    subgraph " "
    direction LR
    F --> M;
    J --> M;
    L --> M;
    end
  
    M[计算LP总手续费 = S 乘以 feeGrowthInside];</pre>
<template>flowchart TD
    A[LP在 i_l, i_u 区间添加流动性] --> B[初始化边界值];
    B --> C[根据当前价格 i_c];
    C --> C1[若 i_l 小于等于 i_c, F_O(i_l) = F_g0];
    C --> C2[若 i_u 大于 i_c, F_O(i_u) = 0];
  
    subgraph " "
    direction LR
    C1 --> D;
    C2 --> D;
    end

    D[交易发生, 价格变动] --> E{价格是否穿越边界?};
  
    E -- 否, 在区间内变动 --> F[feeGrowthInside = 当前F_g - F_g0];
  
    E -- 是 --> H{穿越哪个边界?};
    H -- 向右穿越 i_u --> I[更新 F_O(i_u) = F_g1 - F_O(i_u)_old];
    I --> J[feeGrowthInside = F_g1 - F_g0];
  
    H -- 向左穿越 i_l --> K[更新 F_O(i_l) = F_g1 - F_O(i_l)_old];
    K --> L[feeGrowthInside = F_g1 - F_g0];

    subgraph " "
    direction LR
    F --> M;
    J --> M;
    L --> M;
    end
  
    M[计算LP总手续费 = S 乘以 feeGrowthInside];</template><p><strong>流程解释</strong>：
该图展示了从LP添加流动性开始，如何根据价格变动情况（是否穿越边界）来更新<code>feeGrowthOutside</code>值，并最终计算出区间内的手续费增长<code>feeGrowthInside</code>。这是一个包含条件判断的逻辑过程，因此流程图是最佳的可视化工具。</p>
<h4 id="52-具体计算案例" class="heading-element"><span><strong>5.2 具体计算案例</strong></span>
  <a href="#52-%e5%85%b7%e4%bd%93%e8%ae%a1%e7%ae%97%e6%a1%88%e4%be%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><ul>
<li>
<p><strong>前提</strong>：LP在<code>T=0</code>时刻添加流动性，此时全局<code>feeGrowthGlobal</code>为$F_{g0}$。根据初始化规则，我们得到$F_{O(i_l)} = F_{g0}$和$F_{O(i_u)} = 0$。</p>
</li>
<li>
<p><strong>案例一：价格在区间内变动（未穿越边界）</strong></p>
<ul>
<li><strong>过程</strong>：价格在$i_l$和$i_u$之间波动，但从未穿越它们。</li>
<li><strong>计算</strong>：经过一段时间后，全局<code>feeGrowthGlobal</code>增长到$F_g$。</li>
<li><code>feeGrowthInside</code> = <code>当前全局feeGrowth</code> - <code>初始全局feeGrowth</code> = $F_g - F_{g0}$。</li>
</ul>
</li>
<li>
<p><strong>案例二：向右穿越上限 $i_u$</strong></p>
<ul>
<li><strong>过程</strong>：价格上涨，在<code>T=1</code>时刻穿越了上边界$i_u$，此时的全局<code>feeGrowthGlobal</code>为$F_{g1}$。</li>
<li><strong>边界更新</strong>：
<ul>
<li>$F_{O(i_l)}$未被穿越，保持$F_{g0}$不变。</li>
<li>$F_{O(i_u)}$被穿越，更新为：$F_{O(i_u)<em>{\text{new}}} = F</em>{g1} - F_{O(i_u)<em>{\text{old}}} = F</em>{g1} - 0 = F_{g1}$。</li>
</ul>
</li>
<li><strong>计算</strong>：在这个穿越瞬间，LP在区间内累积的<code>feeGrowthInside</code>为$F_{g1} - F_{g0}$。</li>
</ul>
</li>
<li>
<p><strong>案例三：向左穿越下限 $i_l$</strong></p>
<ul>
<li><strong>过程</strong>：价格下跌，在<code>T=1</code>时刻穿越了下边界$i_l$，此时的全局<code>feeGrowthGlobal</code>为$F_{g1}$。</li>
<li><strong>边界更新</strong>：
<ul>
<li>$F_{O(i_u)}$未被穿越，保持<code>0</code>不变。</li>
<li>$F_{O(i_l)}$被穿越，更新为：$$F_{O(i_l)<em>{\text{new}}} = F</em>{g1} - F_{O(i_l)<em>{\text{old}}} = F</em>{g1} - F_{g0}$$。</li>
</ul>
</li>
<li><strong>计算</strong>：在这个穿越瞬间，LP在区间内累积的<code>feeGrowthInside</code>同样是$F_{g1} - F_{g0}$。</li>
</ul>
</li>
</ul>
<p>通过这套精巧的机制，Uniswap V3实现了在任意价格区间内对LP手续费的精确追踪和计算。</p>
</div><div class="post-footer" id="post-footer">
  <div class="post-info">
    <div class="post-info-line">
      <div class="post-info-mod">
        <span title="Updated on 2025-09-02 00:00:00">Updated on 2025-09-02&nbsp;</span>
      </div><div class="post-info-license">
            <span><a rel="license external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a></span>
          </div></div><div class="post-info-line">
        <div class="post-info-md"></div>
        <div class="post-info-share">
          <span><a href="javascript:void(0);" title="Share on X" data-sharer="twitter" data-url="https://nesl42.github.io/posts/202509-uniswap18/" data-title="18.Uniswap V3 手续费计算（一）" data-hashtags="Web3"><i class="fa-brands fa-x-twitter fa-fw" aria-hidden="true"></i></a>
  <a href="javascript:void(0);" title="Share on Facebook" data-sharer="facebook" data-url="https://nesl42.github.io/posts/202509-uniswap18/" data-hashtag="Web3"><i class="fa-brands fa-facebook-square fa-fw" aria-hidden="true"></i></a>
  <a href="javascript:void(0);" title="Share on 微博" data-sharer="weibo" data-url="https://nesl42.github.io/posts/202509-uniswap18/" data-title="18.Uniswap V3 手续费计算（一）"><i class="fa-brands fa-weibo fa-fw" aria-hidden="true"></i></a>
  </span>
        </div>
      </div></div>

  <div class="post-info-more">
    <section class="post-tags"><i class="fa-solid fa-tags fa-fw me-1" aria-hidden="true"></i><a href="/tags/web3/" class="post-tag" title="Tags - Web3">Web3</a></section>
    <section>
      <span><a href="javascript:void(0);" onclick="window.history.back();">Back</a></span>&nbsp;|&nbsp;<span><a href="/">Home</a></span>
    </section>
  </div><div class="post-nav"><a href="/posts/202509-uniswap19/" class="post-nav-item" rel="prev" title="19.Uniswap V3 手续费计算（二）"><i class="fa-solid fa-angle-left fa-fw" aria-hidden="true"></i>19.Uniswap V3 手续费计算（二）</a><a href="/posts/202509-uniswap16/" class="post-nav-item" rel="next" title="16.Uniswap V3 LiquidityNet">16.Uniswap V3 LiquidityNet<i class="fa-solid fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
</article>

  <aside class="toc" id="toc-auto" aria-label="Contents"><h2 class="toc-title">Contents&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden="true"></i></h2>
      <div class="toc-content always-active" id="toc-content-auto"></div></aside></main><footer class="footer">
    <div class="footer-container"><div class="footer-line powered">Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow noopener noreferrer" title="Hugo 0.149.0"><img class="hugo-icon" src="/images/hugo.min.svg" alt="Hugo logo" /> Hugo</a> | Theme - <a href="https://github.com/hugo-fixit/FixIt" target="_blank" rel="external" title="FixIt v0.3.17-8212d6fd"><img class="fixit-icon" src="/images/fixit.min.svg" alt="FixIt logo" /> FixIt</a>
        </div><div class="footer-line copyright" itemscope itemtype="http://schema.org/CreativeWork"><i class="fa-regular fa-copyright fa-fw" aria-hidden="true"></i>
            <span itemprop="copyrightYear">2025</span><span class="author" itemprop="copyrightHolder">
              <a href="/"></a></span></div></div>
  </footer></div><div class="widgets"><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role="button" aria-label="Back to Top"><i class="fa-solid fa-arrow-up fa-fw" aria-hidden="true"></i><span class="variant-numeric d-none">0%</span>
        </div></div><div id="mask"></div><noscript>
    <div class="noscript-warning">This website works best with JavaScript enabled.</div>
  </noscript>
</div><script type="module">
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.3.0/dist/mermaid.esm.min.mjs';
    
    
    
    window.mermaid = mermaid;
  </script><link rel="preload" href="/lib/katex/katex.min.css" as="style" onload="this.removeAttribute('onload');this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="/lib/katex/katex.min.css"></noscript><link rel="stylesheet" href="/lib/cookieconsent/cookieconsent.min.css"><script src="/lib/sharer/sharer.min.js" async defer></script><script src="/lib/katex/katex.min.js" defer></script><script src="/lib/katex/auto-render.min.js" defer></script><script src="/lib/katex/copy-tex.min.js" defer></script><script src="/lib/katex/mhchem.min.js" defer></script><script src="/lib/cookieconsent/cookieconsent.min.js" defer></script><script>window.config={"code":{"copyTitle":"Copy to clipboard","editLockTitle":"Lock editable code block","editUnLockTitle":"Unlock editable code block","editable":true,"maxShownLines":10},"comment":{"enable":false},"cookieconsent":{"content":{"dismiss":"Got it!","link":"Learn more","message":"This website uses Cookies to improve your experience."},"enable":true,"palette":{"button":{"background":"#f0f0f0"},"popup":{"background":"#1aa3ff"}},"theme":"edgeless"},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":true,"left":"\\begin{equation}","right":"\\end{equation}"},{"display":true,"left":"\\begin{equation*}","right":"\\end{equation*}"},{"display":true,"left":"\\begin{align}","right":"\\end{align}"},{"display":true,"left":"\\begin{align*}","right":"\\end{align*}"},{"display":true,"left":"\\begin{alignat}","right":"\\end{alignat}"},{"display":true,"left":"\\begin{alignat*}","right":"\\end{alignat*}"},{"display":true,"left":"\\begin{gather}","right":"\\end{gather}"},{"display":true,"left":"\\begin{CD}","right":"\\end{CD}"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"mermaid":{"themes":["default","dark"]},"version":"v0.3.17-8212d6fd"};</script><script src="/js/theme.min.js" defer></script></body>
</html>
