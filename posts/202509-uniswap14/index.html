<!DOCTYPE html>
<html itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
    <meta name="robots" content="noodp" />
    <title>14.Uniswap V3 Tick Bitmap - 敬渊&#39;s Blog</title><meta name="author" content="">
<meta name="description" content="核心摘要 (Key Takeaways) Tick BitMap 的核心目的: 为了高效、低成本地跟踪 Uniswap V3 池中哪些价格点（Ticks）被用作了流动性区间的边界，从而知道哪些价格范围是活跃的。 精巧的数据压缩: Tick BitMap 抛弃了为每个 Tick 单独存储状态的朴素方案（成本过高），而是通过位运算将 256 个连续的 Tick 状态压缩存储在一个 uint256 变量中，极大地节省了 Gas 费和存储空间。 关键转换公式: 任何一个 tick (类型为 int24) 都可以通过数学运算定位到它在 BitMap 中的具体位置。其核心是两个坐标：wordPosition (确定在哪一个 uint256 组里) 和 bitPosition (确定在该组的第几位)。 wordPosition = tick / 256 bitPosition = tick % 256 数据结构: Tick BitMap 在合约中实现为一个 mapping(int16 =&gt; uint256)。其中 key (int16) 是 wordPosition，value (uint256) 是一个 256 位的位图，每一位代表一个 tick 的活跃状态（1 表示活跃，0 表示不活跃）。 状态更新机制: 添加或移除流动性时，通过生成一个特定的掩码 (Mask)，并与 BitMap 中对应的 uint256 值进行按位或 (OR) 或按位与 (AND) 运算，来精确地将某一位从 0 改为 1 或从 1 改为 0，而不影响其他位。 1. Tick 的回顾与作用 定义: Tick (也称 Tick Index) 是 Uniswap V3 中用来标记离散化价格点的单位。 价格公式: 价格 P 与 tick T 的关系通过以下公式定义： $$ P = 1.0001^T $$ 其中 T 就是 tick 的索引。当 T 增大时，价格 P 上升；当 T 减小时，价格 P 下降。 Tick 范围: 合约中 tick 的类型为 int24，其理论范围是从 -887272 到 &#43;887272。 案例: 这个范围足以表示极其宽广的价格区间。 当 tick 为 -887272 时，价格约为 $2.938 \times 10^{-39}$。 当 tick 为 &#43;887272 时，价格约为 $3.4 \times 10^{38}$。 这个范围远超比特币等主流资产的价格波动范围，因此在设计上是足够用的。 2. 核心问题：如何跟踪活跃的流动性区间？ 背景: 在 Uniswap V3 中，用户在自定义的价格区间 [PA, PB] (对应 [Tick_A, Tick_B]) 内添加流动性。 挑战: 一个活跃的交易对（如 BTC/USDT）可能有成千上万的用户在各种不同的、甚至重叠的价格区间添加流动性。合约需要一种高效的方式来跟踪哪些 tick 成为了这些流动性区间的边界（即被激活）。 案例: 假设一个用户在 tick 范围 [-10, -5] 添加了流动性，而另一个用户在 [-4, 1] 添加了流动性。此外，还可能存在重叠区间，例如用户 A 在 [6, 10] 添加流动性，用户 B 在 [7, 12] 添加流动性，那么在 [7, 10] 区间内流动性是重叠的。合约必须有效管理这一切。 从 ERC20 到 ERC721: V2: 所有流动性提供者的 LP 凭证是同质化的 ERC20 代币。 V3: 由于每个人的流动性价格区间和数量都可能不同，LP 凭证变成了非同质化的 ERC721 代币（NFT）。 案例: 一个 V3 LP NFT (通过 NonfungiblePositionManager 合约管理) 记录了如 tickLower、tickUpper 和 liquidity (uint128) 等唯一信息，代表一个独一无二的流动性仓位。 根本问题: 尽管 NFT 记录了每个仓位的具体信息，但 Pool 合约本身如何宏观地、低成本地知道在任意一个 tick 上，是否有流动性边界存在？ 3. 一种被否决的朴素方案 思路: 设计一个简单的键值对（Key-Value）结构来记录每个 tick 的状态。 mapping(int24 =&gt; bool) Key: tick 索引 (例如: -10000, 20000) Value: true (被用作边界) 或 false (未被用作边界) 致命缺陷: 存储量巨大: tick 的总数约有 177 万个。为每一个 tick 都创建一个存储槽位在区块链上是无法承受的，成本极高。 计算量巨大 (高 Gas 费): 当一笔交易（swap）需要跨越成千上万个 tick 时，如果需要逐一查询这些 tick 的状态，将会导致交易的 Gas 费极高，用户无法接受。 4. Uniswap V3 的精巧解决方案：Tick BitMap "><meta name="keywords" content='Web3'>
  <meta itemprop="name" content="14.Uniswap V3 Tick Bitmap">
  <meta itemprop="description" content="核心摘要 (Key Takeaways) Tick BitMap 的核心目的: 为了高效、低成本地跟踪 Uniswap V3 池中哪些价格点（Ticks）被用作了流动性区间的边界，从而知道哪些价格范围是活跃的。 精巧的数据压缩: Tick BitMap 抛弃了为每个 Tick 单独存储状态的朴素方案（成本过高），而是通过位运算将 256 个连续的 Tick 状态压缩存储在一个 uint256 变量中，极大地节省了 Gas 费和存储空间。 关键转换公式: 任何一个 tick (类型为 int24) 都可以通过数学运算定位到它在 BitMap 中的具体位置。其核心是两个坐标：wordPosition (确定在哪一个 uint256 组里) 和 bitPosition (确定在该组的第几位)。 wordPosition = tick / 256 bitPosition = tick % 256 数据结构: Tick BitMap 在合约中实现为一个 mapping(int16 =&gt; uint256)。其中 key (int16) 是 wordPosition，value (uint256) 是一个 256 位的位图，每一位代表一个 tick 的活跃状态（1 表示活跃，0 表示不活跃）。 状态更新机制: 添加或移除流动性时，通过生成一个特定的掩码 (Mask)，并与 BitMap 中对应的 uint256 值进行按位或 (OR) 或按位与 (AND) 运算，来精确地将某一位从 0 改为 1 或从 1 改为 0，而不影响其他位。 1. Tick 的回顾与作用 定义: Tick (也称 Tick Index) 是 Uniswap V3 中用来标记离散化价格点的单位。 价格公式: 价格 P 与 tick T 的关系通过以下公式定义： $$ P = 1.0001^T $$ 其中 T 就是 tick 的索引。当 T 增大时，价格 P 上升；当 T 减小时，价格 P 下降。 Tick 范围: 合约中 tick 的类型为 int24，其理论范围是从 -887272 到 &#43;887272。 案例: 这个范围足以表示极其宽广的价格区间。 当 tick 为 -887272 时，价格约为 $2.938 \times 10^{-39}$。 当 tick 为 &#43;887272 时，价格约为 $3.4 \times 10^{38}$。 这个范围远超比特币等主流资产的价格波动范围，因此在设计上是足够用的。 2. 核心问题：如何跟踪活跃的流动性区间？ 背景: 在 Uniswap V3 中，用户在自定义的价格区间 [PA, PB] (对应 [Tick_A, Tick_B]) 内添加流动性。 挑战: 一个活跃的交易对（如 BTC/USDT）可能有成千上万的用户在各种不同的、甚至重叠的价格区间添加流动性。合约需要一种高效的方式来跟踪哪些 tick 成为了这些流动性区间的边界（即被激活）。 案例: 假设一个用户在 tick 范围 [-10, -5] 添加了流动性，而另一个用户在 [-4, 1] 添加了流动性。此外，还可能存在重叠区间，例如用户 A 在 [6, 10] 添加流动性，用户 B 在 [7, 12] 添加流动性，那么在 [7, 10] 区间内流动性是重叠的。合约必须有效管理这一切。 从 ERC20 到 ERC721: V2: 所有流动性提供者的 LP 凭证是同质化的 ERC20 代币。 V3: 由于每个人的流动性价格区间和数量都可能不同，LP 凭证变成了非同质化的 ERC721 代币（NFT）。 案例: 一个 V3 LP NFT (通过 NonfungiblePositionManager 合约管理) 记录了如 tickLower、tickUpper 和 liquidity (uint128) 等唯一信息，代表一个独一无二的流动性仓位。 根本问题: 尽管 NFT 记录了每个仓位的具体信息，但 Pool 合约本身如何宏观地、低成本地知道在任意一个 tick 上，是否有流动性边界存在？ 3. 一种被否决的朴素方案 思路: 设计一个简单的键值对（Key-Value）结构来记录每个 tick 的状态。 mapping(int24 =&gt; bool) Key: tick 索引 (例如: -10000, 20000) Value: true (被用作边界) 或 false (未被用作边界) 致命缺陷: 存储量巨大: tick 的总数约有 177 万个。为每一个 tick 都创建一个存储槽位在区块链上是无法承受的，成本极高。 计算量巨大 (高 Gas 费): 当一笔交易（swap）需要跨越成千上万个 tick 时，如果需要逐一查询这些 tick 的状态，将会导致交易的 Gas 费极高，用户无法接受。 4. Uniswap V3 的精巧解决方案：Tick BitMap">
  <meta itemprop="datePublished" content="2025-09-02T00:00:00+00:00">
  <meta itemprop="dateModified" content="2025-09-02T00:00:00+00:00">
  <meta itemprop="wordCount" content="3361">
  <meta itemprop="keywords" content="Web3"><meta property="og:url" content="http://localhost:1313/posts/202509-uniswap14/">
  <meta property="og:site_name" content="敬渊&#39;s Blog">
  <meta property="og:title" content="14.Uniswap V3 Tick Bitmap">
  <meta property="og:description" content="核心摘要 (Key Takeaways) Tick BitMap 的核心目的: 为了高效、低成本地跟踪 Uniswap V3 池中哪些价格点（Ticks）被用作了流动性区间的边界，从而知道哪些价格范围是活跃的。 精巧的数据压缩: Tick BitMap 抛弃了为每个 Tick 单独存储状态的朴素方案（成本过高），而是通过位运算将 256 个连续的 Tick 状态压缩存储在一个 uint256 变量中，极大地节省了 Gas 费和存储空间。 关键转换公式: 任何一个 tick (类型为 int24) 都可以通过数学运算定位到它在 BitMap 中的具体位置。其核心是两个坐标：wordPosition (确定在哪一个 uint256 组里) 和 bitPosition (确定在该组的第几位)。 wordPosition = tick / 256 bitPosition = tick % 256 数据结构: Tick BitMap 在合约中实现为一个 mapping(int16 =&gt; uint256)。其中 key (int16) 是 wordPosition，value (uint256) 是一个 256 位的位图，每一位代表一个 tick 的活跃状态（1 表示活跃，0 表示不活跃）。 状态更新机制: 添加或移除流动性时，通过生成一个特定的掩码 (Mask)，并与 BitMap 中对应的 uint256 值进行按位或 (OR) 或按位与 (AND) 运算，来精确地将某一位从 0 改为 1 或从 1 改为 0，而不影响其他位。 1. Tick 的回顾与作用 定义: Tick (也称 Tick Index) 是 Uniswap V3 中用来标记离散化价格点的单位。 价格公式: 价格 P 与 tick T 的关系通过以下公式定义： $$ P = 1.0001^T $$ 其中 T 就是 tick 的索引。当 T 增大时，价格 P 上升；当 T 减小时，价格 P 下降。 Tick 范围: 合约中 tick 的类型为 int24，其理论范围是从 -887272 到 &#43;887272。 案例: 这个范围足以表示极其宽广的价格区间。 当 tick 为 -887272 时，价格约为 $2.938 \times 10^{-39}$。 当 tick 为 &#43;887272 时，价格约为 $3.4 \times 10^{38}$。 这个范围远超比特币等主流资产的价格波动范围，因此在设计上是足够用的。 2. 核心问题：如何跟踪活跃的流动性区间？ 背景: 在 Uniswap V3 中，用户在自定义的价格区间 [PA, PB] (对应 [Tick_A, Tick_B]) 内添加流动性。 挑战: 一个活跃的交易对（如 BTC/USDT）可能有成千上万的用户在各种不同的、甚至重叠的价格区间添加流动性。合约需要一种高效的方式来跟踪哪些 tick 成为了这些流动性区间的边界（即被激活）。 案例: 假设一个用户在 tick 范围 [-10, -5] 添加了流动性，而另一个用户在 [-4, 1] 添加了流动性。此外，还可能存在重叠区间，例如用户 A 在 [6, 10] 添加流动性，用户 B 在 [7, 12] 添加流动性，那么在 [7, 10] 区间内流动性是重叠的。合约必须有效管理这一切。 从 ERC20 到 ERC721: V2: 所有流动性提供者的 LP 凭证是同质化的 ERC20 代币。 V3: 由于每个人的流动性价格区间和数量都可能不同，LP 凭证变成了非同质化的 ERC721 代币（NFT）。 案例: 一个 V3 LP NFT (通过 NonfungiblePositionManager 合约管理) 记录了如 tickLower、tickUpper 和 liquidity (uint128) 等唯一信息，代表一个独一无二的流动性仓位。 根本问题: 尽管 NFT 记录了每个仓位的具体信息，但 Pool 合约本身如何宏观地、低成本地知道在任意一个 tick 上，是否有流动性边界存在？ 3. 一种被否决的朴素方案 思路: 设计一个简单的键值对（Key-Value）结构来记录每个 tick 的状态。 mapping(int24 =&gt; bool) Key: tick 索引 (例如: -10000, 20000) Value: true (被用作边界) 或 false (未被用作边界) 致命缺陷: 存储量巨大: tick 的总数约有 177 万个。为每一个 tick 都创建一个存储槽位在区块链上是无法承受的，成本极高。 计算量巨大 (高 Gas 费): 当一笔交易（swap）需要跨越成千上万个 tick 时，如果需要逐一查询这些 tick 的状态，将会导致交易的 Gas 费极高，用户无法接受。 4. Uniswap V3 的精巧解决方案：Tick BitMap">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-09-02T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-09-02T00:00:00+00:00">
    <meta property="article:tag" content="Web3">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="14.Uniswap V3 Tick Bitmap">
  <meta name="twitter:description" content="核心摘要 (Key Takeaways) Tick BitMap 的核心目的: 为了高效、低成本地跟踪 Uniswap V3 池中哪些价格点（Ticks）被用作了流动性区间的边界，从而知道哪些价格范围是活跃的。 精巧的数据压缩: Tick BitMap 抛弃了为每个 Tick 单独存储状态的朴素方案（成本过高），而是通过位运算将 256 个连续的 Tick 状态压缩存储在一个 uint256 变量中，极大地节省了 Gas 费和存储空间。 关键转换公式: 任何一个 tick (类型为 int24) 都可以通过数学运算定位到它在 BitMap 中的具体位置。其核心是两个坐标：wordPosition (确定在哪一个 uint256 组里) 和 bitPosition (确定在该组的第几位)。 wordPosition = tick / 256 bitPosition = tick % 256 数据结构: Tick BitMap 在合约中实现为一个 mapping(int16 =&gt; uint256)。其中 key (int16) 是 wordPosition，value (uint256) 是一个 256 位的位图，每一位代表一个 tick 的活跃状态（1 表示活跃，0 表示不活跃）。 状态更新机制: 添加或移除流动性时，通过生成一个特定的掩码 (Mask)，并与 BitMap 中对应的 uint256 值进行按位或 (OR) 或按位与 (AND) 运算，来精确地将某一位从 0 改为 1 或从 1 改为 0，而不影响其他位。 1. Tick 的回顾与作用 定义: Tick (也称 Tick Index) 是 Uniswap V3 中用来标记离散化价格点的单位。 价格公式: 价格 P 与 tick T 的关系通过以下公式定义： $$ P = 1.0001^T $$ 其中 T 就是 tick 的索引。当 T 增大时，价格 P 上升；当 T 减小时，价格 P 下降。 Tick 范围: 合约中 tick 的类型为 int24，其理论范围是从 -887272 到 &#43;887272。 案例: 这个范围足以表示极其宽广的价格区间。 当 tick 为 -887272 时，价格约为 $2.938 \times 10^{-39}$。 当 tick 为 &#43;887272 时，价格约为 $3.4 \times 10^{38}$。 这个范围远超比特币等主流资产的价格波动范围，因此在设计上是足够用的。 2. 核心问题：如何跟踪活跃的流动性区间？ 背景: 在 Uniswap V3 中，用户在自定义的价格区间 [PA, PB] (对应 [Tick_A, Tick_B]) 内添加流动性。 挑战: 一个活跃的交易对（如 BTC/USDT）可能有成千上万的用户在各种不同的、甚至重叠的价格区间添加流动性。合约需要一种高效的方式来跟踪哪些 tick 成为了这些流动性区间的边界（即被激活）。 案例: 假设一个用户在 tick 范围 [-10, -5] 添加了流动性，而另一个用户在 [-4, 1] 添加了流动性。此外，还可能存在重叠区间，例如用户 A 在 [6, 10] 添加流动性，用户 B 在 [7, 12] 添加流动性，那么在 [7, 10] 区间内流动性是重叠的。合约必须有效管理这一切。 从 ERC20 到 ERC721: V2: 所有流动性提供者的 LP 凭证是同质化的 ERC20 代币。 V3: 由于每个人的流动性价格区间和数量都可能不同，LP 凭证变成了非同质化的 ERC721 代币（NFT）。 案例: 一个 V3 LP NFT (通过 NonfungiblePositionManager 合约管理) 记录了如 tickLower、tickUpper 和 liquidity (uint128) 等唯一信息，代表一个独一无二的流动性仓位。 根本问题: 尽管 NFT 记录了每个仓位的具体信息，但 Pool 合约本身如何宏观地、低成本地知道在任意一个 tick 上，是否有流动性边界存在？ 3. 一种被否决的朴素方案 思路: 设计一个简单的键值对（Key-Value）结构来记录每个 tick 的状态。 mapping(int24 =&gt; bool) Key: tick 索引 (例如: -10000, 20000) Value: true (被用作边界) 或 false (未被用作边界) 致命缺陷: 存储量巨大: tick 的总数约有 177 万个。为每一个 tick 都创建一个存储槽位在区块链上是无法承受的，成本极高。 计算量巨大 (高 Gas 费): 当一笔交易（swap）需要跨越成千上万个 tick 时，如果需要逐一查询这些 tick 的状态，将会导致交易的 Gas 费极高，用户无法接受。 4. Uniswap V3 的精巧解决方案：Tick BitMap">
<meta name="application-name" content="FixIt">
<meta name="apple-mobile-web-app-title" content="FixIt"><meta name="theme-color" data-light="#f8f8f8" data-dark="#252627" content="#f8f8f8"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="canonical" type="text/html" href="http://localhost:1313/posts/202509-uniswap14/" title="14.Uniswap V3 Tick Bitmap - 敬渊&#39;s Blog" /><link rel="prev" type="text/html" href="http://localhost:1313/posts/202509-uniswap15/" title="15.Uniswap V3 Tick Bitmap 寻找下一个 tick" /><link rel="next" type="text/html" href="http://localhost:1313/posts/202509-uniswap13/" title="13.Uniswap V3 单价格区间内 Swap 机制" /><link rel="stylesheet" href="/css/config.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="/lib/fontawesome-free/all.min.css" as="style" onload="this.removeAttribute('onload');this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"></noscript><link rel="preload" href="/lib/animate/animate.min.css" as="style" onload="this.removeAttribute('onload');this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="/lib/animate/animate.min.css"></noscript><script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "headline": "14.Uniswap V3 Tick Bitmap",
    "inLanguage": "zh-CN",
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "http:\/\/localhost:1313\/posts\/202509-uniswap14\/"
    },"genre": "posts","keywords": "Web3","wordcount":  3361 ,
    "url": "http:\/\/localhost:1313\/posts\/202509-uniswap14\/","datePublished": "2025-09-02T00:00:00+00:00","dateModified": "2025-09-02T00:00:00+00:00","publisher": {
      "@type": "Organization",
      "name": ""},"author": {
        "@type": "Person",
        "name": "作者"
      },"description": ""
  }
  </script><script src="/js/head/color-scheme.min.js"></script></head>
  <body data-instant-intensity="viewport" data-header-desktop="sticky" data-header-mobile="auto"><div class="wrapper" data-page-style="normal"><header class="desktop animate__faster" id="header-desktop">
  <div class="header-wrapper">
    <div class="header-title">
      <a href="/" title="敬渊&#39;s Blog"><span class="header-title-text">敬渊&#39;s Blog</span></a><span class="header-subtitle"></span></div>
    <nav>
      <ul class="menu"><li class="menu-item">
              <a class="menu-link" href="/posts/">文章</a></li><li class="menu-item">
              <a class="menu-link" href="/tags/">标签</a></li><li class="menu-item">
              <a class="menu-link" href="/about/">关于</a></li><li class="menu-item">
              <a class="menu-link" href="/categories/">分类</a></li><li class="menu-item delimiter"></li><li class="menu-item theme-switch" role="button" aria-label="切换主题" title="切换主题"><i class="fa-solid fa-adjust" aria-hidden="true"></i></li></ul>
    </nav>
  </div>
</header><header class="mobile animate__faster" id="header-mobile">
  <div class="header-container">
    <div class="header-wrapper">
      <div class="header-title">
        <a href="/" title="敬渊&#39;s Blog"><span class="header-title-text">敬渊&#39;s Blog</span></a><span class="header-subtitle"></span></div>
      <div class="theme-switch" role="button" aria-label="切换主题"><i class="fa-solid fa-adjust" aria-hidden="true"></i></div>
      <div class="menu-toggle" id="menu-toggle-mobile" role="button" aria-labelledby="menu-mobile">
        <span></span><span></span><span></span>
      </div>
    </div>
    <nav>
      <ul class="menu" id="menu-mobile"><li class="menu-item"><a class="menu-link" href="/posts/">文章</a></li><li class="menu-item"><a class="menu-link" href="/tags/">标签</a></li><li class="menu-item"><a class="menu-link" href="/about/">关于</a></li><li class="menu-item"><a class="menu-link" href="/categories/">分类</a></li><li class="menu-item menu-system"></li>
      </ul>
    </nav>
  </div>
</header><main class="fi-container"><aside class="aside-collection animate__animated animate__fadeIn animate__faster" aria-label="合集"></aside>

  <article class="page single">
    <div class="header"><h1 class="single-title animate__animated animate__flipInX"><span>14.Uniswap V3 Tick Bitmap</span>
      </h1></div><div class="post-meta">
      <div class="post-meta-line"><span class="post-author"><span class="author"><i class="fa-solid fa-user-circle" aria-hidden="true"></i>
      Anonymous</span></span><span class="post-included-in">&nbsp;收录于 <a href="/categories/technology/" class="post-category" title="分类 - Technology"><i class="fa-regular fa-folder" aria-hidden="true"></i> Technology</a></span></div><div class="post-meta-line"><span title="发布于 2025-09-02 00:00:00"><i class="fa-solid fa-calendar-days me-1" aria-hidden="true"></i><time datetime="2025-09-02">2025-09-02</time></span>&nbsp;<span title="3361 字"><i class="fa-solid fa-pencil-alt me-1" aria-hidden="true"></i>约 3400 字</span>&nbsp;<span><i class="fa-regular fa-clock me-1" aria-hidden="true"></i>预计阅读 7 分钟</span>&nbsp;</div>
    </div><div class="details toc" id="toc-static" data-kept="false">
        <div class="details-summary toc-title">
          <span>目录</span>
          <span><i class="details-icon fa-solid fa-angle-right" aria-hidden="true"></i></span>
        </div>
        <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#核心摘要-key-takeaways"><strong>核心摘要 (Key Takeaways)</strong></a></li>
        <li><a href="#1-tick-的回顾与作用"><strong>1. Tick 的回顾与作用</strong></a></li>
        <li><a href="#2-核心问题如何跟踪活跃的流动性区间"><strong>2. 核心问题：如何跟踪活跃的流动性区间？</strong></a></li>
        <li><a href="#3-一种被否决的朴素方案"><strong>3. 一种被否决的朴素方案</strong></a></li>
        <li><a href="#4-uniswap-v3-的精巧解决方案tick-bitmap"><strong>4. Uniswap V3 的精巧解决方案：Tick BitMap</strong></a>
          <ul>
            <li><a href="#41-tick-bitmap-的核心思想"><strong>4.1 Tick BitMap 的核心思想</strong></a></li>
            <li><a href="#42-从-tick-到-word-position-和-bit-position-的转换"><strong>4.2 从 Tick 到 Word Position 和 Bit Position 的转换</strong></a></li>
            <li><a href="#43-数据结构与工作原理"><strong>4.3 数据结构与工作原理</strong></a></li>
            <li><a href="#44-流动性的更新操作-添加与移除"><strong>4.4 流动性的更新操作 (添加与移除)</strong></a></li>
          </ul>
        </li>
        <li><a href="#5-可视化流程更新-tick-bitmap"><strong>5. 可视化流程：更新 Tick BitMap</strong></a></li>
      </ul>
    </li>
  </ul>
</nav></div>
      </div><div class="content" id="content"><h3 class="heading-element" id="核心摘要-key-takeaways"><span><strong>核心摘要 (Key Takeaways)</strong></span>
  <a href="#%e6%a0%b8%e5%bf%83%e6%91%98%e8%a6%81-key-takeaways" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li><strong>Tick BitMap 的核心目的</strong>: 为了高效、低成本地跟踪 Uniswap V3 池中哪些价格点（Ticks）被用作了流动性区间的边界，从而知道哪些价格范围是活跃的。</li>
<li><strong>精巧的数据压缩</strong>: <code>Tick BitMap</code> 抛弃了为每个 Tick 单独存储状态的朴素方案（成本过高），而是通过位运算将 256 个连续的 Tick 状态压缩存储在一个 <code>uint256</code> 变量中，极大地节省了 Gas 费和存储空间。</li>
<li><strong>关键转换公式</strong>: 任何一个 <code>tick</code> (类型为 <code>int24</code>) 都可以通过数学运算定位到它在 BitMap 中的具体位置。其核心是两个坐标：<code>wordPosition</code> (确定在哪一个 <code>uint256</code> 组里) 和 <code>bitPosition</code> (确定在该组的第几位)。
<ul>
<li><code>wordPosition = tick / 256</code></li>
<li><code>bitPosition = tick % 256</code></li>
</ul>
</li>
<li><strong>数据结构</strong>: <code>Tick BitMap</code> 在合约中实现为一个 <code>mapping(int16 =&gt; uint256)</code>。其中 <code>key (int16)</code> 是 <code>wordPosition</code>，<code>value (uint256)</code> 是一个 256 位的位图，每一位代表一个 <code>tick</code> 的活跃状态（1 表示活跃，0 表示不活跃）。</li>
<li><strong>状态更新机制</strong>: 添加或移除流动性时，通过生成一个特定的<strong>掩码 (Mask)</strong>，并与 BitMap 中对应的 <code>uint256</code> 值进行<strong>按位或 (OR)</strong> 或<strong>按位与 (AND)</strong> 运算，来精确地将某一位从 0 改为 1 或从 1 改为 0，而不影响其他位。</li>
</ul>
<hr>
<h3 class="heading-element" id="1-tick-的回顾与作用"><span><strong>1. Tick 的回顾与作用</strong></span>
  <a href="#1-tick-%e7%9a%84%e5%9b%9e%e9%a1%be%e4%b8%8e%e4%bd%9c%e7%94%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li><strong>定义</strong>: <strong>Tick</strong> (也称 <strong>Tick Index</strong>) 是 Uniswap V3 中用来标记离散化价格点的单位。</li>
<li><strong>价格公式</strong>: 价格 <code>P</code> 与 <code>tick</code> <code>T</code> 的关系通过以下公式定义：
$$
P = 1.0001^T
$$
其中 <code>T</code> 就是 <code>tick</code> 的索引。当 <code>T</code> 增大时，价格 <code>P</code> 上升；当 <code>T</code> 减小时，价格 <code>P</code> 下降。</li>
<li><strong>Tick 范围</strong>:
<ul>
<li>合约中 <code>tick</code> 的类型为 <code>int24</code>，其理论范围是从 <code>-887272</code> 到 <code>+887272</code>。</li>
<li><strong>案例</strong>: 这个范围足以表示极其宽广的价格区间。
<ul>
<li>当 <code>tick</code> 为 <code>-887272</code> 时，价格约为 $2.938 \times 10^{-39}$。</li>
<li>当 <code>tick</code> 为 <code>+887272</code> 时，价格约为 $3.4 \times 10^{38}$。</li>
<li>这个范围远超比特币等主流资产的价格波动范围，因此在设计上是足够用的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 class="heading-element" id="2-核心问题如何跟踪活跃的流动性区间"><span><strong>2. 核心问题：如何跟踪活跃的流动性区间？</strong></span>
  <a href="#2-%e6%a0%b8%e5%bf%83%e9%97%ae%e9%a2%98%e5%a6%82%e4%bd%95%e8%b7%9f%e8%b8%aa%e6%b4%bb%e8%b7%83%e7%9a%84%e6%b5%81%e5%8a%a8%e6%80%a7%e5%8c%ba%e9%97%b4" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li><strong>背景</strong>: 在 Uniswap V3 中，用户在自定义的价格区间 <code>[PA, PB]</code> (对应 <code>[Tick_A, Tick_B]</code>) 内添加流动性。</li>
<li><strong>挑战</strong>: 一个活跃的交易对（如 BTC/USDT）可能有成千上万的用户在各种不同的、甚至重叠的价格区间添加流动性。合约需要一种高效的方式来跟踪哪些 <code>tick</code> 成为了这些流动性区间的边界（即被激活）。
<ul>
<li><strong>案例</strong>: 假设一个用户在 <code>tick</code> 范围 <code>[-10, -5]</code> 添加了流动性，而另一个用户在 <code>[-4, 1]</code> 添加了流动性。此外，还可能存在重叠区间，例如用户 A 在 <code>[6, 10]</code> 添加流动性，用户 B 在 <code>[7, 12]</code> 添加流动性，那么在 <code>[7, 10]</code> 区间内流动性是重叠的。合约必须有效管理这一切。</li>
</ul>
</li>
<li><strong>从 ERC20 到 ERC721</strong>:
<ul>
<li><strong>V2</strong>: 所有流动性提供者的 LP 凭证是同质化的 <strong>ERC20</strong> 代币。</li>
<li><strong>V3</strong>: 由于每个人的流动性价格区间和数量都可能不同，LP 凭证变成了非同质化的 <strong>ERC721</strong> 代币（NFT）。</li>
<li><strong>案例</strong>: 一个 V3 LP NFT (通过 <code>NonfungiblePositionManager</code> 合约管理) 记录了如 <code>tickLower</code>、<code>tickUpper</code> 和 <code>liquidity (uint128)</code> 等唯一信息，代表一个独一无二的流动性仓位。</li>
</ul>
</li>
<li><strong>根本问题</strong>: 尽管 NFT 记录了每个仓位的具体信息，但 <code>Pool</code> 合约本身如何宏观地、低成本地知道在任意一个 <code>tick</code> 上，是否有流动性边界存在？</li>
</ul>
<h3 class="heading-element" id="3-一种被否决的朴素方案"><span><strong>3. 一种被否决的朴素方案</strong></span>
  <a href="#3-%e4%b8%80%e7%a7%8d%e8%a2%ab%e5%90%a6%e5%86%b3%e7%9a%84%e6%9c%b4%e7%b4%a0%e6%96%b9%e6%a1%88" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li><strong>思路</strong>: 设计一个简单的键值对（Key-Value）结构来记录每个 <code>tick</code> 的状态。
<ul>
<li><code>mapping(int24 =&gt; bool)</code></li>
<li><code>Key</code>: <code>tick</code> 索引 (例如: -10000, 20000)</li>
<li><code>Value</code>: <code>true</code> (被用作边界) 或 <code>false</code> (未被用作边界)</li>
</ul>
</li>
<li><strong>致命缺陷</strong>:
<ol>
<li><strong>存储量巨大</strong>: <code>tick</code> 的总数约有 177 万个。为每一个 <code>tick</code> 都创建一个存储槽位在区块链上是无法承受的，成本极高。</li>
<li><strong>计算量巨大 (高 Gas 费)</strong>: 当一笔交易（swap）需要跨越成千上万个 <code>tick</code> 时，如果需要逐一查询这些 <code>tick</code> 的状态，将会导致交易的 Gas 费极高，用户无法接受。</li>
</ol>
</li>
</ul>
<h3 class="heading-element" id="4-uniswap-v3-的精巧解决方案tick-bitmap"><span><strong>4. Uniswap V3 的精巧解决方案：Tick BitMap</strong></span>
  <a href="#4-uniswap-v3-%e7%9a%84%e7%b2%be%e5%b7%a7%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88tick-bitmap" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p><img loading="lazy" src='/posts/202509-uniswap14/tick_bitmap.png' alt="Tick indexes in tick bitmap" height="432" width="1058"></p>
<h4 class="heading-element" id="41-tick-bitmap-的核心思想"><span><strong>4.1 Tick BitMap 的核心思想</strong></span>
  <a href="#41-tick-bitmap-%e7%9a%84%e6%a0%b8%e5%bf%83%e6%80%9d%e6%83%b3" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p><code>Tick BitMap</code> 是一种数据压缩技术，它没有为每个 <code>tick</code> 单独存储信息，而是将连续的 256 个 <code>tick</code> 的状态打包到一个 256 位的整数 (<code>uint256</code>) 中进行管理。</p>
<h4 class="heading-element" id="42-从-tick-到-word-position-和-bit-position-的转换"><span><strong>4.2 从 Tick 到 Word Position 和 Bit Position 的转换</strong></span>
  <a href="#42-%e4%bb%8e-tick-%e5%88%b0-word-position-%e5%92%8c-bit-position-%e7%9a%84%e8%bd%ac%e6%8d%a2" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>为了定位任意一个 <code>tick</code> 在 BitMap 中的精确位置，需要将其转换为两个坐标：<code>wordPosition</code> 和 <code>bitPosition</code>。这本质上是将一个 <code>int24</code> 类型的 <code>tick</code> 值，在概念上拆分为两部分：</p>
<ul>
<li><strong>前 16 位</strong>: 用于确定 <code>wordPosition</code>，对应 <code>mapping</code> 的 <code>key</code> (<code>int16</code>)。</li>
<li><strong>后 8 位</strong>: 用于确定 <code>bitPosition</code>，对应 <code>value</code> (<code>uint256</code>) 中的具体位置 (<code>uint8</code>)。</li>
</ul>
<p><strong>转换公式</strong>:</p>
<ul>
<li>
<p><strong><code>wordPosition</code> (商)</strong>: 决定了该 <code>tick</code> 属于哪一个 <code>uint256</code> &ldquo;字&rdquo; (word)。
$$
wordPosition = \lfloor \frac{tick}{256} \rfloor
$$</p>
</li>
<li>
<p><strong><code>bitPosition</code> (余数)</strong>: 决定了该 <code>tick</code> 在其所属的 <code>uint256</code> &ldquo;字&rdquo; 中的具体哪一位 (从 0 到 255)。
$$
bitPosition = tick \pmod{256}
$$</p>
</li>
<li>
<p><strong>反向还原公式</strong>:
$$
tick = (wordPosition \times 256) + bitPosition
$$</p>
</li>
<li>
<p><strong>代码实现</strong>: 在 Solidity 合约中，为了节省 Gas，通常使用位运算实现：</p>
<ul>
<li>除法 <code>/ 256</code> 等价于 <strong>右移 8 位 <code>&gt;&gt; 8</code></strong>。</li>
<li>取余 <code>% 256</code> 可以直接计算。</li>
</ul>
</li>
<li>
<p><strong>案例 (视频中的核心例子)</strong>:</p>
<ul>
<li>假设 <code>tick = -200697</code>。</li>
<li><strong>计算 <code>wordPosition</code></strong>: <code>-200697 / 256 = -783.97...</code>，向负无穷方向取整得到 <strong>-784</strong>。</li>
<li><strong>计算 <code>bitPosition</code></strong>: <code>-200697 % 256 = 7</code>。</li>
<li><strong>结论</strong>: <code>tick -200697</code> 的状态信息，存储在 <code>wordPosition</code> 为 <code>-784</code> 的那个 <code>uint256</code> 值的<strong>第 7 位</strong>上（索引从0开始）。</li>
</ul>
</li>
</ul>
<h4 class="heading-element" id="43-数据结构与工作原理"><span><strong>4.3 数据结构与工作原理</strong></span>
  <a href="#43-%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><ul>
<li><strong>合约内定义</strong>:</li>
</ul>
<div class="code-block highlight line-nos-hidden" data-mode="classic" data-copyable="true"><div class="code-header language-solidity"><span class="code-title"><i class="arrow fa-solid fa-chevron-down" aria-hidden="true"></i></span><span class="ellipses-btn" aria-label="Show more options" role="button"><i class="fa-solid fa-ellipsis-h" aria-hidden="true"></i></span><span class="line-nos-btn" aria-label="切换行号" role="button" title="切换行号"><i class="fa-solid fa-list-ol" aria-hidden="true"></i></span><span class="line-wrap-btn" aria-label="切换自动换行" role="button" title="切换自动换行"><i class="fa-solid fa-right-left" aria-hidden="true"></i></span><span class="copy-btn" aria-label="复制到剪贴板" role="button" title="复制到剪贴板"><i class="fa-regular fa-clone" aria-hidden="true"></i></span></div><div class="code-wrapper" data-max="10" data-line-digit="1" style="--fi-max-shown-lines:10;--fi-line-digit:1;--fi-line-start:1;"><pre tabindex="0" class="chroma"><code class="language-solidity" data-lang="solidity"><span class="line"><span class="cl"><span class="kd">mapping</span><span class="p">(</span><span class="kt">int16</span> <span class="o">=&gt;</span> <span class="kt">uint256</span><span class="p">)</span> <span class="k">public</span> <span class="n">tickBitmaps</span><span class="p">;</span></span></span></code></pre></div></div><ul>
<li><code>key (int16)</code>: 就是计算出的 <code>wordPosition</code>。</li>
<li><code>value (uint256)</code> : 一个 256 位的位图。它本身不是一个有数值意义的数字，而是一个 <strong>标记序列</strong> ，其中每一位（0或1）代表对应 <code>tick</code> 的活跃状态。</li>
</ul>
<h4 class="heading-element" id="44-流动性的更新操作-添加与移除"><span><strong>4.4 流动性的更新操作 (添加与移除)</strong></span>
  <a href="#44-%e6%b5%81%e5%8a%a8%e6%80%a7%e7%9a%84%e6%9b%b4%e6%96%b0%e6%93%8d%e4%bd%9c-%e6%b7%bb%e5%8a%a0%e4%b8%8e%e7%a7%bb%e9%99%a4" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>更新特定 <code>tick</code> 的状态是通过<strong>位运算</strong>完成的，这比直接读写存储要高效得多。</p>
<ul>
<li>
<p><strong>添加流动性 (将某位置为 1)</strong></p>
<ol>
<li><strong>目标</strong>: 将 <code>wordPosition</code> 对应 <code>uint256</code> 值的第 <code>bitPosition</code> 位置为 <code>1</code>，且不改变其他位。</li>
<li><strong>生成掩码 (Mask)</strong>: 创建一个 <code>uint256</code> 的掩码，其中只有第 <code>bitPosition</code> 位是 <code>1</code>，其余所有位都是 <code>0</code>。(通过 <code>1 &lt;&lt; bitPosition</code> 实现)。</li>
<li><strong>执行运算</strong>: 将原始的 <code>uint256</code> 值与这个掩码进行 <strong>按位或 (<code>OR</code> 或 <code>|</code>)</strong> 运算。
<ul>
<li><code>X OR 1 = 1</code> (将目标位置为 1)</li>
<li><code>X OR 0 = X</code> (其他位保持不变)</li>
</ul>
</li>
</ol>
</li>
<li>
<p><strong>移除流动性 (将某位置为 0)</strong></p>
<ol>
<li><strong>目标</strong>: 将 <code>wordPosition</code> 对应 <code>uint256</code> 值的第 <code>bitPosition</code> 位置为 <code>0</code>，且不改变其他位。</li>
<li><strong>生成掩码 (Mask)</strong>: 创建一个 <code>uint256</code> 的掩码，其中只有第 <code>bitPosition</code> 位是 <code>0</code>，其余所有位都是 <code>1</code>。(通过对&quot;添加&quot;掩码进行<strong>按位取反 (<code>NOT</code> 或 <code>~</code>)</strong> 实现)。</li>
<li><strong>执行运算</strong>: 将原始的 <code>uint256</code> 值与这个掩码进行 <strong>按位与 (<code>AND</code> 或 <code>&amp;</code>)</strong> 运算。
<ul>
<li><code>X AND 0 = 0</code> (将目标位置为 0)</li>
<li><code>X AND 1 = X</code> (其他位保持不变)</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 class="heading-element" id="5-可视化流程更新-tick-bitmap"><span><strong>5. 可视化流程：更新 Tick BitMap</strong></span>
  <a href="#5-%e5%8f%af%e8%a7%86%e5%8c%96%e6%b5%81%e7%a8%8b%e6%9b%b4%e6%96%b0-tick-bitmap" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p><strong>图表选择说明</strong>:
此处选择<strong>流程图 (Flowchart)</strong> 是最合适的。因为我们的目标是清晰地展示一个<strong>算法的内部处理步骤和决策逻辑</strong>。</p>
<ul>
<li><strong>时序图 (Sequence Diagram)</strong> 更侧重于不同对象/角色之间的消息传递和交互顺序，不适合展现内部计算逻辑。</li>
<li><strong>甘特图 (Gantt Chart)</strong> 用于项目管理和时间规划，与此场景完全无关。</li>
</ul>
<div class="diagram-container">
  <pre class="mermaid">graph LR
    A[开始: 更新Tick的活跃状态] --> B{输入 Tick 值};
    B --> C[1:计算坐标<br>wordPosition = tick / 256<br>bitPosition = tick % 256];
    C --> D[2:根据 wordPosition<br>从 tickBitmaps 中读取原始的 uint256 值];
    D --> E{操作是添加还是移除流动性?};
  
    E -- 添加 --> F[3a. 生成'添加'掩码 Mask<br>即第 bitPosition 位为1, 其余为0];
    F --> G[4a. 执行按位'或'操作<br>新值 = 原始值 OR Mask];
  
    E -- 移除 --> H[3b. 生成'移除'掩码 Mask<br>即第 bitPosition 位为0, 其余为1];
    H --> I[4b. 执行按位'与'操作<br>新值 = 原始值 AND Mask];
  
    G --> J[5: 将新值写回 tickBitmaps];
    I --> J;
    J --> K[结束];</pre>
  <pre class="mermaid-dark">graph LR
    A[开始: 更新Tick的活跃状态] --> B{输入 Tick 值};
    B --> C[1:计算坐标<br>wordPosition = tick / 256<br>bitPosition = tick % 256];
    C --> D[2:根据 wordPosition<br>从 tickBitmaps 中读取原始的 uint256 值];
    D --> E{操作是添加还是移除流动性?};
  
    E -- 添加 --> F[3a. 生成'添加'掩码 Mask<br>即第 bitPosition 位为1, 其余为0];
    F --> G[4a. 执行按位'或'操作<br>新值 = 原始值 OR Mask];
  
    E -- 移除 --> H[3b. 生成'移除'掩码 Mask<br>即第 bitPosition 位为0, 其余为1];
    H --> I[4b. 执行按位'与'操作<br>新值 = 原始值 AND Mask];
  
    G --> J[5: 将新值写回 tickBitmaps];
    I --> J;
    J --> K[结束];</pre>
  <pre class="mermaid-neutral">graph LR
    A[开始: 更新Tick的活跃状态] --> B{输入 Tick 值};
    B --> C[1:计算坐标<br>wordPosition = tick / 256<br>bitPosition = tick % 256];
    C --> D[2:根据 wordPosition<br>从 tickBitmaps 中读取原始的 uint256 值];
    D --> E{操作是添加还是移除流动性?};
  
    E -- 添加 --> F[3a. 生成'添加'掩码 Mask<br>即第 bitPosition 位为1, 其余为0];
    F --> G[4a. 执行按位'或'操作<br>新值 = 原始值 OR Mask];
  
    E -- 移除 --> H[3b. 生成'移除'掩码 Mask<br>即第 bitPosition 位为0, 其余为1];
    H --> I[4b. 执行按位'与'操作<br>新值 = 原始值 AND Mask];
  
    G --> J[5: 将新值写回 tickBitmaps];
    I --> J;
    J --> K[结束];</pre><div class="diagram-copy-btn" aria-label="Copy Mermaid code" role="button"><i class="fa-regular fa-clone fa-width-auto" aria-hidden="true"></i></div>
<template><pre>graph LR
    A[开始: 更新Tick的活跃状态] --> B{输入 Tick 值};
    B --> C[1:计算坐标<br>wordPosition = tick / 256<br>bitPosition = tick % 256];
    C --> D[2:根据 wordPosition<br>从 tickBitmaps 中读取原始的 uint256 值];
    D --> E{操作是添加还是移除流动性?};
  
    E -- 添加 --> F[3a. 生成'添加'掩码 Mask<br>即第 bitPosition 位为1, 其余为0];
    F --> G[4a. 执行按位'或'操作<br>新值 = 原始值 OR Mask];
  
    E -- 移除 --> H[3b. 生成'移除'掩码 Mask<br>即第 bitPosition 位为0, 其余为1];
    H --> I[4b. 执行按位'与'操作<br>新值 = 原始值 AND Mask];
  
    G --> J[5: 将新值写回 tickBitmaps];
    I --> J;
    J --> K[结束];</pre></template>
</div><p><strong>流程解释</strong>:</p>
<ol>
<li>当需要更新一个 <code>tick</code> 的状态时，首先输入该 <code>tick</code> 的值。</li>
<li>合约通过除以 256 和对 256 取余，计算出该 <code>tick</code> 对应的 <code>wordPosition</code> 和 <code>bitPosition</code>。</li>
<li>使用 <code>wordPosition</code> 作为键，从 <code>tickBitmaps</code> 这个 <code>mapping</code> 中找到对应的 256 位 <code>uint256</code> 值。</li>
<li>根据操作是添加还是移除流动性，生成不同的掩码（Mask）并执行相应的位运算（<code>OR</code> 或 <code>AND</code>）。</li>
<li>最后，将运算后得到的新 <code>uint256</code> 值更新回 <code>tickBitmaps</code> 中，完成状态更新。这个过程只修改了一位，效率极高。</li>
</ol>
</div><div class="post-footer" id="post-footer">
  <div class="post-info">
    <div class="post-info-line">
      <div class="post-info-mod"><span title="更新于 2025-09-02 00:00:00">更新于 2025-09-02&nbsp;</span>
      </div><div class="post-info-license">
            <span><a rel="license external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a></span>
          </div></div><div class="post-info-line">
        <div class="post-info-md"><span><a href="vscode://file//Users/ghostasky/Blog/content/posts/202509-Uniswap14/index.md" title="在编辑器中打开" target="_blank" rel="external nofollow noopener noreferrer" class="link-to-vscode">在编辑器中打开</a></span></div>
        <div class="post-info-share">
          <span><a href="javascript:void(0);" title="分享到 X" data-sharer="twitter" data-url="http://localhost:1313/posts/202509-uniswap14/" data-title="14.Uniswap V3 Tick Bitmap" data-hashtags="Web3"><i class="fa-brands fa-x-twitter" aria-hidden="true"></i></a>
  <a href="javascript:void(0);" title="分享到 Facebook" data-sharer="facebook" data-url="http://localhost:1313/posts/202509-uniswap14/" data-hashtag="Web3"><i class="fa-brands fa-facebook-square" aria-hidden="true"></i></a>
  <a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="http://localhost:1313/posts/202509-uniswap14/" data-title="14.Uniswap V3 Tick Bitmap"><i class="fa-brands fa-weibo" aria-hidden="true"></i></a>
  </span>
        </div>
      </div></div>

  <div class="post-info-more">
    <section class="post-tags"><i class="fa-solid fa-tags me-1" aria-hidden="true"></i><a href="/tags/web3/" class="post-tag" title="标签 - Web3">Web3</a></section>
    <section><span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
    </section>
  </div><div class="post-nav"><a href="/posts/202509-uniswap15/" class="post-nav-item" rel="prev" title="15.Uniswap V3 Tick Bitmap 寻找下一个 Tick"><i class="fa-solid fa-angle-left" aria-hidden="true"></i>15.Uniswap V3 Tick Bitmap 寻找下一个 Tick</a><a href="/posts/202509-uniswap13/" class="post-nav-item" rel="next" title="13.Uniswap V3 单价格区间内 Swap 机制">13.Uniswap V3 单价格区间内 Swap 机制<i class="fa-solid fa-angle-right" aria-hidden="true"></i></a></div>
</div>
</article>

  <aside class="toc" id="toc-auto" aria-label="目录"><h2 class="toc-title">目录&nbsp;<i class="toc-icon fa-solid fa-angle-down" aria-hidden="true"></i></h2>
      <div class="toc-content" id="toc-content-auto"></div></aside><dialog id="toc-dialog" aria-labelledby="toc-dialog-title" role="dialog">
      <div class="toc">
        <h2 class="toc-title">目录</h2>
        <div class="toc-content" id="toc-content-drawer"><nav >
  <ul>
    <li>
      <ul>
        <li><a href="#核心摘要-key-takeaways"><strong>核心摘要 (Key Takeaways)</strong></a></li>
        <li><a href="#1-tick-的回顾与作用"><strong>1. Tick 的回顾与作用</strong></a></li>
        <li><a href="#2-核心问题如何跟踪活跃的流动性区间"><strong>2. 核心问题：如何跟踪活跃的流动性区间？</strong></a></li>
        <li><a href="#3-一种被否决的朴素方案"><strong>3. 一种被否决的朴素方案</strong></a></li>
        <li><a href="#4-uniswap-v3-的精巧解决方案tick-bitmap"><strong>4. Uniswap V3 的精巧解决方案：Tick BitMap</strong></a>
          <ul>
            <li><a href="#41-tick-bitmap-的核心思想"><strong>4.1 Tick BitMap 的核心思想</strong></a></li>
            <li><a href="#42-从-tick-到-word-position-和-bit-position-的转换"><strong>4.2 从 Tick 到 Word Position 和 Bit Position 的转换</strong></a></li>
            <li><a href="#43-数据结构与工作原理"><strong>4.3 数据结构与工作原理</strong></a></li>
            <li><a href="#44-流动性的更新操作-添加与移除"><strong>4.4 流动性的更新操作 (添加与移除)</strong></a></li>
          </ul>
        </li>
        <li><a href="#5-可视化流程更新-tick-bitmap"><strong>5. 可视化流程：更新 Tick BitMap</strong></a></li>
      </ul>
    </li>
  </ul>
</nav></div>
      </div>
    </dialog></main><footer class="footer">
    <div class="footer-container"><div class="footer-line powered">由 <a href="https://gohugo.io/" target="_blank" rel="external nofollow noopener noreferrer" title="Hugo 0.154.5"><img class="hugo-icon" src="/images/hugo.min.svg" alt="Hugo logo" /> Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/hugo-fixit/FixIt" target="_blank" rel="external" title="FixIt v0.4.3-20260123080729-2a5bd268"><img class="fixit-icon" src="/images/fixit.min.svg" alt="FixIt logo" /> FixIt</a>
        </div><div class="footer-line copyright" itemscope itemtype="http://schema.org/CreativeWork"><i class="fa-regular fa-copyright" aria-hidden="true"></i>
            <span itemprop="copyrightYear">2026</span><span class="author" itemprop="copyrightHolder">
              <a href="/"></a></span></div></div>
  </footer></div><div class="widgets"><div class="fixed-buttons"><div class="fixed-button back-to-top animate__faster d-none" role="button" aria-label="回到顶部"><i class="fa-solid fa-arrow-up" aria-hidden="true"></i></div><div id="toc-drawer-button" class="fixed-button toc-drawer-button d-none" role="button" aria-label="目录"><i class="fa-solid fa-bars" aria-hidden="true"></i></div></div><div id="mask"></div><noscript>
    <div class="noscript-warning">该网站在启用 JavaScript 的情况下效果最佳。</div>
  </noscript>
</div><link rel="stylesheet" href="/lib/cookieconsent/cookieconsent.min.css"><script src="/lib/sharer/sharer.min.js" async defer></script><script src="/lib/cookieconsent/cookieconsent.min.js" defer></script><script src="/js/config/35cdc2af197332a2762321222485a1a2.js" defer></script><script src="/js/lib/mermaid.js" type="module"></script><script src="/js/theme.min.js" defer></script></body>
</html>
